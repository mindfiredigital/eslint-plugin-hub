Directory structure:
└── eslint-plugin-hub/
    ├── README.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── LICENSE.md
    ├── SECURITY.md
    ├── babel.config.js
    ├── commitlint.config.js
    ├── eslint.config.mjs
    ├── index.d.ts
    ├── index.js
    ├── index.mjs
    ├── jest.config.js
    ├── package.json
    ├── tsconfig.json
    ├── .npmignore
    ├── .prettierignore
    ├── .prettierrc
    ├── configs/
    │   ├── flat-config-base.js
    │   └── legacy-config-base.js
    ├── lib/
    │   ├── rules/
    │   │   ├── advanced/
    │   │   │   ├── index.js
    │   │   │   └── plugin/
    │   │   │       ├── avoid-runtime-heap-allocation.js
    │   │   │       ├── check-return-values.js
    │   │   │       ├── fixed-loop-bounds.js
    │   │   │       ├── keep-functions-concise.js
    │   │   │       ├── limit-data-scope.js
    │   │   │       ├── limit-reference-depth.js
    │   │   │       ├── minimize-complexflows.js
    │   │   │       ├── minimize-deep-asynchronous-chains.js
    │   │   │       └── use-runtime-assertions.js
    │   │   ├── angular/
    │   │   │   ├── index.js
    │   │   │   └── plugin/
    │   │   │       ├── angular-filenaming.js
    │   │   │       ├── angular-limit-input.js
    │   │   │       ├── angular-no-direct-dom-manipulation.js
    │   │   │       ├── angular-no-forbidden-services.js
    │   │   │       └── angular-no-unused-inputs.js
    │   │   ├── general/
    │   │   │   ├── index.js
    │   │   │   └── plugin/
    │   │   │       ├── class-pascalcase.js
    │   │   │       ├── consistent-return.js
    │   │   │       ├── file-camelcase.js
    │   │   │       ├── file-kebabcase.js
    │   │   │       ├── file-lowercase.js
    │   │   │       ├── file-pascalcase.js
    │   │   │       ├── folder-camelcase.js
    │   │   │       ├── folder-kebabcase.js
    │   │   │       ├── folder-lowercase.js
    │   │   │       ├── folder-pascalcase.js
    │   │   │       ├── function-camelcase.js
    │   │   │       ├── function-descriptive.js
    │   │   │       ├── function-pascalcase.js
    │   │   │       ├── max-function-params.js
    │   │   │       ├── max-lines-per-file.js
    │   │   │       ├── max-lines-per-function.js
    │   │   │       ├── no-single-character-vars.js
    │   │   │       ├── vars-camelcase.js
    │   │   │       ├── vars-descriptive.js
    │   │   │       ├── vars-lowercase.js
    │   │   │       ├── vars-pascalcase.js
    │   │   │       └── vars-snakecase.js
    │   │   ├── node/
    │   │   │   ├── index.js
    │   │   │   └── express/
    │   │   │       ├── index.js
    │   │   │       └── open-api-spec/
    │   │   │           ├── index.js
    │   │   │           └── plugin/
    │   │   │               └── http-status-code.js
    │   │   └── react/
    │   │       ├── index.js
    │   │       └── plugin/
    │   │           ├── react-component-name-match-filename.js
    │   │           └── react-filename-pascalcase.js
    │   └── utils/
    │       ├── check-eslint-config.js
    │       └── check-verb.js
    ├── script/
    │   ├── generate-rule.js
    │   └── templates/
    │       ├── angular-test-template.js
    │       ├── react-test-template.js
    │       ├── rule-template.js
    │       └── test-template.js
    ├── test/
    │   ├── advanced/
    │   │   ├── avoid-runtime-heap-allocation.test.js
    │   │   ├── check-return-values.test.js
    │   │   ├── fixed-loop-bound.test.js
    │   │   ├── keep-functions-concise.test.js
    │   │   ├── limit-data-scope.test.js
    │   │   ├── limit-reference-depth.test.js
    │   │   ├── minimize-complexflow.test.js
    │   │   ├── minimize-deep-asynchronous-chains.test.js
    │   │   └── use-runtime-assertions.test.js
    │   ├── angular/
    │   │   ├── angular-filenaming.test.js
    │   │   ├── angular-limit-input.test.js
    │   │   ├── angular-no-direct-dom-manipulation.test.js
    │   │   ├── angular-no-forbidden-services.test.js
    │   │   └── angular-no-unused-inputs.test.js
    │   ├── express/
    │   │   └── http-status-code.test.js
    │   ├── general/
    │   │   ├── class-pascalcase.test.js
    │   │   ├── consistent-return.test.js
    │   │   ├── file-camelcase.test.js
    │   │   ├── file-kebabcase.test.js
    │   │   ├── file-lowercase.test.js
    │   │   ├── file-pascalcase.test.js
    │   │   ├── folder-camelcase.test.js
    │   │   ├── folder-kebabcase.test.js
    │   │   ├── folder-lowercase.test.js
    │   │   ├── folder-pascalcase.test.js
    │   │   ├── function-camelcase.test.js
    │   │   ├── function-descriptive.test.js
    │   │   ├── function-pascalcase.test.js
    │   │   ├── max-function-params.test.js
    │   │   ├── max-lines-per-file.test.js
    │   │   ├── max-lines-per-function.test.js
    │   │   ├── no-single-character-vars.test.js
    │   │   ├── vars-camelcase.test.js
    │   │   ├── vars-descriptive.test.js
    │   │   ├── vars-lowercase.test.js
    │   │   ├── vars-pascalcase.test.js
    │   │   └── vars-snakecase.test.js
    │   └── react/
    │       ├── react-component-name-match-filename.test.js
    │       └── react-filename-pascalcase.test.js
    ├── .github/
    │   ├── PULL_REQUEST_TEMPLATE.md
    │   ├── ISSUE_TEMPLATE/
    │   │   ├── bug_report.md
    │   │   ├── rule_change.md
    │   │   └── rule_proposal.md
    │   └── workflows/
    │       └── release.yml
    └── .husky/
        ├── commit-msg
        ├── pre-commit
        └── _/
            ├── applypatch-msg
            ├── commit-msg
            ├── h
            ├── husky.sh
            ├── post-applypatch
            ├── post-checkout
            ├── post-commit
            ├── post-merge
            ├── post-rewrite
            ├── pre-applypatch
            ├── pre-auto-gc
            ├── pre-commit
            ├── pre-merge-commit
            ├── pre-push
            ├── pre-rebase
            ├── prepare-commit-msg
            └── .gitignore

================================================
File: README.md
================================================
<h1 align="center">ESLint Plugin Hub</h1><br>
<p align="center">
<a href="https://www.npmjs.com/package/@mindfiredigital/eslint-plugin-hub"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg" alt="PRs"></a>
<a href="https://www.npmjs.com/package/@mindfiredigital/eslint-plugin-hub">
  <img src="https://img.shields.io/npm/dt/@mindfiredigital/eslint-plugin-hub.svg" alt="Total Downloads">
</a>
</p>

<p align="center">
  <img src="https://mindfiredigital.github.io/_next/static/media/mindfire_foss_logo.0c507a60.png" alt="Mindfire Logo" width="200">
</p>
<p align="center"> A collection of custom ESLint rules to enforce coding standards and best practices in your projects. </p>

The `@mindfiredigital/eslint-plugin-hub` aims to help maintain consistent code quality and readability by providing rules for variable names, class names, file names, function naming conventions etc.
<br>

## Table of Contents

- [Installation](#installation)
- [Rules](#rules)
  - [General Rules](#general-rules)
  - [React Rules](#react-rules)
  - [Angular Rules](#angular-rules)
  - [Advanced Rules](#advanced-rules)
- [Usage](#usage)
  - [Flat Configuration (`eslint.config.js`)](#flat-configuration-eslintconfigjs)
    - [For ES Module](#for-es-module)
    - [For CommonJS](#for-commonjs)
  - [Legacy Configuration (`.eslintrc.*`, `package.json`)](#legacy-configuration-eslintrc-or-eslintrcjson)
    - [For `.eslintrc.json`](#for-eslintrcjson)
    - [For ES Module `.eslintrc.js`](#for-es-module-eslintrcjs)
    - [For CommonJS `.eslintrc.cjs`](#for-commonjs-eslintrcjs)
  - [MERN Recommended Rules](#mern-recommended-rules)
    - [Example: Extending MERN Config](#example-extending-mern-config)
      - [For `eslint.config.mjs`](#for-eslintconfigmjs)
      - [For `.eslintrc.cjs`](#for-eslintrccjs)
      - [For `.eslintrc.json`](#for-eslintrcjson-1)
  - [Extending Presets in Flat Configuration (`eslint.config.mjs`)](#extending-presets-in-flat-configuration-eslintconfigmjs)
    - [Example: Extending General Config](#example-extending-general-config)
    - [Example: Extending React Config](#example-extending-react-config)
    - [Example: Extending Angular Config](#example-extending-angular-config)
  - [Extending Presets in Legacy Configuration (`.eslintrc.*`, `.eslintrc.js` or `package.json`)](#extending-presets-in-legacy-configuration-eslintrc-or-packagejson)
    - [Example: Extending General Config](#example-extending-general-config-1)
    - [Example: Extending React Config](#example-extending-react-config-1)
    - [Example: Extending Angular Config](#example-extending-angular-config-1)
- [Documentation](#documentation)
- [License](#license)

## Installation

To install and use this ESLint plugin, make sure you have ESLint already set up in your project **Requires ESLint `>=8.56.0`.** Then add the plugin as a dependency with npm or yarn:

```bash
npm install @mindfiredigital/eslint-plugin-hub --save-dev
```

or

```bash
yarn add @mindfiredigital/eslint-plugin-hub --dev
```

## Rules

This plugin provides the following rules:

### General Rules

| Rule Name                  | Description                                               |
| -------------------------- | --------------------------------------------------------- |
| `file-kebabcase`           | Enforces kebab-case naming convention for filenames.      |
| `max-lines-per-file`       | Enforces a maximum number of lines per file.              |
| `max-lines-per-function`   | Enforces a maximum number of lines per function.          |
| `consistent-return`        | Enforces consistent return statements in functions.       |
| `max-function-params`      | Enforces a maximum number of parameters in functions.     |
| `no-single-character-vars` | Disallows single-character variable names.                |
| `vars-lowercase`           | Enforces lowercase naming convention for variables.       |
| `folder-lowercase`         | Enforces lowercase naming convention for folder names.    |
| `file-lowercase`           | Enforces lowercase naming convention for filenames.       |
| `folder-pascalcase`        | Enforces PascalCase naming convention for folder names.   |
| `folder-kebabcase`         | Enforces kebab-case naming convention for folder names.   |
| `folder-camelcase`         | Enforces camelCase naming convention for folder names.    |
| `file-camelcase`           | Enforces camelCase naming convention for filenames.       |
| `function-pascalcase`      | Enforces PascalCase naming convention for function names. |
| `file-pascalcase`          | Enforces PascalCase naming convention for filenames.      |
| `vars-snakecase`           | Enforces snake_case naming convention for variables.      |
| `vars-pascalcase`          | Enforces PascalCase naming convention for variables.      |
| `class-pascalcase`         | Enforces PascalCase naming convention for class names.    |
| `function-camelcase`       | Enforces camelCase naming convention for function names.  |
| `function-descriptive`     | Enforces descriptive names for functions.                 |
| `vars-camelcase`           | Enforces camelCase naming convention for variables.       |
| `vars-descriptive`         | Enforces descriptive names for variables.                 |

### React Rules

| Rule Name                             | Description                                                          |
| ------------------------------------- | -------------------------------------------------------------------- |
| `react-component-name-match-filename` | Enforces that React component names match their filenames.           |
| `react-filename-pascalcase`           | Enforces PascalCase naming convention for React component filenames. |

### Angular Rules

| Rule Name                            | Description                                                     |
| ------------------------------------ | --------------------------------------------------------------- |
| `angular-no-forbidden-services`      | Disallows usage of forbidden Angular services.                  |
| `angular-no-unused-inputs`           | Disallows unused inputs in Angular components.                  |
| `angular-no-direct-dom-manipulation` | Disallows direct DOM manipulation in Angular components.        |
| `angular-limit-input`                | Enforces a limit on the number of inputs in Angular components. |
| `angular-filenaming`                 | Enforces consistent naming conventions for Angular files.       |

### Advanced Rules

| Rule Name                           | Description                                                                                                                                                                                                          |
| ----------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `avoid-runtime-heap-allocation`     | Discourages heap allocation of common data structures (arrays, objects, Maps, Sets) within function bodies, especially in loops, to promote reuse of pre-allocated structures and reduce garbage collection pressure |
| `minimize-complexflows`             | Enforces simplified control flow by limiting recursion and nesting depth, and detecting direct or lexically scoped recursion                                                                                         |
| `check-return-values`               | Enforces handling of return values from non-void functions. If the return value is intentionally not used, it should be explicitly ignored                                                                           |
| `fixed-loop-bounds`                 | Enforces that loops have clearly defined bounds or deterministic exit conditions to prevent potentially infinite loops                                                                                               |
| `use-runtime-assertions`            | Enforces the presence of a minimum number of runtime assertions in functions to validate inputs and critical intermediate values                                                                                     |
| `minimize-deep-asynchronous-chains` | Limits the depth of Promise chains and the number of `await` expressions in async functions                                                                                                                          |
| `limit-data-scope`                  | Enforces several best practices for data scoping: disallows global object modification, suggests moving variables to their narrowest functional scope, and discourages `var` usage.                                  |
| `limit-reference-depth`             | Restricts the depth of chained property access and enforces optional chaining to prevent runtime errors, improve null safety, and encourage safer access patterns in deeply nested data structures.                  |
| `keep-functions-concise`            | Enforces a maximum number of lines per function, with options to skip blank lines and comments, to promote readability, maintainability, and concise logic blocks.                                                   |

## Usage

You can enable the plugin and configure the rules using either flat or legacy configurations.

### Flat Configuration (`eslint.config.mjs`)

This is for ESLint `>=8.56.0` using the new flat config format.

#### For ES Module

```js
import hub from '@mindfiredigital/eslint-plugin-hub';
import globals from 'globals';

export default [
  {
    languageOptions: {
      globals: globals.builtin,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
      },
    },
    plugins: {
      hub: hub,
    },
    rules: {
      'hub/vars-camelcase': 'error',
      'hub/class-pascalcase': 'error',
      'hub/file-kebabcase': 'error',
      'hub/function-camelcase': 'error',
      'hub/function-descriptive': 'warn',
    },
  },
];
```

#### For CommonJS

```js
const hub = require('@mindfiredigital/eslint-plugin-hub');
const globals = require('globals');

module.exports = [
  {
    languageOptions: {
      globals: globals.builtin,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
      },
    },
    plugins: {
      hub: hub,
    },
    rules: {
      'hub/vars-camelcase': 'error',
      'hub/class-pascalcase': 'error',
      'hub/file-kebabcase': 'error',
      'hub/function-camelcase': 'error',
      'hub/function-descriptive': 'warn',
    },
  },
];
```

### Legacy Configuration (`.eslintrc.*` or `eslintrc.json`)

If you're using the legacy ESLint configuration format, here's how to use the plugin.

#### For `.eslintrc.json`:

```json
{
  "env": {
    "es2024": true
  },
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": ["@mindfiredigital/eslint-plugin-hub"],
  "rules": {
    "@mindfiredigital/hub/file-kebabcase": "error",
    "@mindfiredigital/hub/function-camelcase": "error",
    "@mindfiredigital/hub/vars-camelcase": "error"
  }
}
```

#### For ES Module `.eslintrc.js`:

```javascript
export default [
  {
  env: {
    browser: true,
    es2024: true,
  },
  parserOptions: {
    ecmaVersion: "latest",
    sourceType: "module",
  },
  rules: {
    "@mindfiredigital/hub/file-kebabcase": "error",
    "@mindfiredigital/hub/function-camelcase": "error",
    "@mindfiredigital/hub/vars-camelcase": "error",
  },
};
];
```

#### For CommonJS `.eslintrc.cjs`:

```javascript
module.exports = {
  env: {
    browser: true,
    es2024: true,
  },
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
  rules: {
    '@mindfiredigital/hub/file-kebabcase': 'error',
    '@mindfiredigital/hub/function-camelcase': 'error',
    '@mindfiredigital/hub/vars-camelcase': 'error',
  },
};
```

### MERN Recommended Rules

The MERN configuration includes a set of recommended rules optimized for MongoDB, Express, React, and Node.js stack projects. Below is a table showing the recommended rules for both legacy and flat configurations:

| Rule Description                                       | Legacy Configuration                                       | Flat Configuration                        | Severity |
| ------------------------------------------------------ | ---------------------------------------------------------- | ----------------------------------------- | -------- |
| Enforce kebab-case for filenames                       | `@mindfiredigital/hub/file-kebabcase`                      | `hub/file-kebabcase`                      | error    |
| Enforce camelCase for variables                        | `@mindfiredigital/hub/vars-camelcase`                      | `hub/vars-camelcase`                      | error    |
| Enforce PascalCase for class names                     | `@mindfiredigital/hub/class-pascalcase`                    | `hub/class-pascalcase`                    | error    |
| Enforce camelCase for function names                   | `@mindfiredigital/hub/function-camelcase`                  | `hub/function-camelcase`                  | error    |
| Enforce descriptive function names                     | `@mindfiredigital/hub/function-descriptive`                | `hub/function-descriptive`                | warn     |
| Enforce React component names to match their filenames | `@mindfiredigital/hub/react-component-name-match-filename` | `hub/react-component-name-match-filename` | error    |
| Enforce PascalCase for React component filenames       | `@mindfiredigital/hub/react-filename-pascalcase`           | `hub/react-filename-pascalcase`           | error    |

These rules are automatically included when you extend the MERN configuration in your ESLint setup.

##### Example: Extending MERN Config

#### For `eslint.config.mjs`:

```js
import hub from '@mindfiredigital/eslint-plugin-hub';
import globals from 'globals';

export default [
  // Extends the mern config preset from the plugin
  hub.configs['flat/mern'],
  {
    languageOptions: {
      globals: globals.builtin,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    // Add any additional rules or overrides here
  },
];
```

#### For `.eslintrc.cjs`:

```javascript
module.exports = {
  env: {
    browser: true,
    es2024: true,
  },
  extends: ['plugin:@mindfiredigital/hub/mern'],
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
  rules: {
    '@mindfiredigital/hub/file-kebabcase': 'error',
    '@mindfiredigital/hub/function-camelcase': 'error',
    '@mindfiredigital/hub/vars-camelcase': 'error',
  },
};
```

#### For `.eslintrc.json`:

```json
{
  "env": {
    "es2024": true
  },
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "extends": ["plugin:@mindfiredigital/hub/mern"]
  // Add any additional rules or overrides here
}
```

The MERN config includes the recommended rules listed in the table above. When extending this configuration, all these rules will be automatically applied to your project. You can override or add additional rules as needed in your specific configuration file.

#### Extending Presets in Flat Configuration (`eslint.config.mjs`)

You can extend the `hub.configs` presets directly into your flat ESLint configuration. When extending these presets, all rules in the respective category will be automatically added with their default configurations.

##### Example: Extending General Config

```js
import hub from '@mindfiredigital/eslint-plugin-hub';
import globals from 'globals';

export default [
  // Extends the general config preset from the plugin
  hub.configs['flat/general'],
  {
    languageOptions: {
      globals: globals.builtin,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
      },
    },
    // Add any additional rules or overrides here
  },
];
```

##### Example: Extending React Config

```js
import hub from '@mindfiredigital/eslint-plugin-hub';
import globals from 'globals';

export default [
  // Extends the react config preset from the plugin
  hub.configs['flat/react'],
  {
    languageOptions: {
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    // Add any additional rules or overrides here
  },
];
```

##### Example: Extending Angular Config

```js
import hub from '@mindfiredigital/eslint-plugin-hub';
import globals from 'globals';

export default [
  // Extends the angular config preset from the plugin
  hub.configs['flat/angular'],
  {
    languageOptions: {
      globals: globals.builtin,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
      },
    },
    // Add any additional rules or overrides here
  },
];
```

#### Extending Presets in Legacy Configuration (`.eslintrc.*`,`.eslintrc.js` or `package.json`)

For older versions of ESLint, or if you're using the legacy configuration format, you can extend the same configs with the `extends` field. This will inherit all the rules from the plugin presets for the respective category.

##### Example: Extending General Config

```json
{
  "env": {
    "es2024": true
  },
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "extends": ["plugin:@mindfiredigital/hub/general"]
  // Add any additional rules or overrides here
}
```

##### Example: Extending React Config

```json
{
  "env": {
    "es2024": true
  },
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "extends": ["plugin:@mindfiredigital/hub/react"]
  // Add any additional rules or overrides here
}
```

##### Example: Extending Angular Config

```json
{
  "env": {
    "es2024": true
  },
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "extends": ["plugin:@mindfiredigital/hub/angular"]
  // Add any additional rules or overrides here
}
```

## Documentation

The documentation for each rule is available at our [official documentation site](https://mindfiredigital.github.io/eslint-plugin-hub/). You can find detailed usage instructions, examples, and best practices for each rule.

If you're contributing to the documentation, please follow the instructions in the `CONTRIBUTING.md` file for how to structure and update the documentation in the `docs/docusaurus` branch.

## License

ESLint Plugin Hub is licensed under the MIT License. See the [LICENSE](LICENSE.md) file for more details.



================================================
File: CODE_OF_CONDUCT.md
================================================
# Code of Conduct - eslint plugin hub

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to make participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
- Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or
  advances
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or email
  address, without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, or to ban
temporarily or permanently any contributor for other behaviors that they deem
inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at <>.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://contributor-covenant.org/), version
[1.4](https://www.contributor-covenant.org/version/1/4/code-of-conduct/code_of_conduct.md) and
[2.0](https://www.contributor-covenant.org/version/2/0/code_of_conduct/code_of_conduct.md),
and was generated by [contributing-gen](https://github.com/bttger/contributing-gen).



================================================
File: CONTRIBUTING.md
================================================
# Contributing to ESLint Plugin Hub

We welcome and appreciate your contributions to the ESLint Plugin Hub. To ensure a smooth and collaborative process, please follow these guidelines.

## How Can You Contribute?

Here are some ways you can contribute to the project:

- Reporting bugs or issues
- Suggesting new rules or features
- Writing or improving documentation
- Fixing bugs
- Implementing new rules or features

## Steps for Contributing

1. **Fork** the repository to your GitHub account.
2. **Clone** the forked repository to your local machine:

   ```bash
   git clone https://github.com/mindfiredigital/eslint-plugin-hub.git
   ```

3. Create a new **branch** for your feature or fix:

   ```bash
   git checkout -b feature/new-login or bugfix/header-styling.
   ```

4. **Make changes** and **test** to ensure they work as expected.
5. **Commit** your changes:

   ```bash
   git commit -m 'Your descriptive commit message'
   ```

6. **Push** your branch to your GitHub repository:

   ```bash
   git push origin feature-name
   ```

7. Create a **Pull Request (PR)** from your branch to the original repository's `main` branch.

## Commit Message Format

We follow the conventional commit message format to ensure consistent and meaningful commit messages. This format helps in automated versioning and release notes generation.

### Commit Types

- **feat:** A new feature or significant change.
- **fix:** A bug fix or issue resolution.
- **docs:** Documentation changes.
- **chore:** Routine tasks, maintenance, or tooling changes.

### How to Write Commit Messages

- Start the commit message with the type, followed by a colon and a space (e.g., `feat: Add new rule`).
- Provide a concise and descriptive commit message.
- If the commit addresses an issue or feature request, include the issue number in the message (e.g., `fix: Resolve issue #123`).

### Example Commit Messages

- feat: Add new rule for variable naming
- fix: Correct issue #456 with class name validation
- docs: Update usage instructions in README
- chore: Upgrade dependencies to latest versions

### Commitlint Configuration

We use Commitlint to enforce the commit message format. Ensure that your commits adhere to the specified format. You can find the Commitlint configuration in the repository.

For more details on Commitlint and conventional commits, please refer to [Commitlint Documentation](https://commitlint.js.org/).

## Pull Request Guidelines

- Make sure your PR addresses an issue or feature request.
- Provide a clear description of your PR and any relevant context.
- Keep your PR focused on a single change to facilitate review.
- Ensure your code follows the project's coding style and conventions.
- Include tests for any new rules or changes to existing ones.

## Documentation Guidelines

When contributing to the documentation, please add your updates in the `docs/docusaurus` branch inside the `docs-docusaurus` folder within the `docs` folder. This helps keep the documentation organized and easily accessible.

## Code of Conduct and Licensing

Please ensure your contributions adhere to the project's [Code of Conduct](./CODE_OF_CONDUCT.md) and are licensed under the project's [License](./LICENSE).

## Need Help?

If you have questions or need assistance, feel free to create an issue or directly contact the maintainers.

Thank you for your interest in contributing to ESLint Plugin Hub! We appreciate your efforts in making this project better.

Happy contributing!



================================================
File: LICENSE.md
================================================
MIT License

Copyright (c) 2024 Mindfire Digital LLP

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: SECURITY.md
================================================
# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability in this project, please follow these steps:

1. **Do not report security vulnerabilities in public**: Please report security vulnerabilities privately. Publicly disclosing vulnerabilities can lead to potential risks and exploits.

2. **Contact us directly**: Send a detailed report to our security team at [security@yourdomain.com](mailto:security@yourdomain.com). Provide as much detail as possible, including:

   - Description of the vulnerability
   - Steps to reproduce the issue
   - The impact of the vulnerability
   - Any potential exploits or examples

3. **Be patient**: Our team will review your report and respond as quickly as possible. We appreciate your patience as we work to address the issue.

4. **Security Bug Bounty**: If you are interested in participating in our bug bounty program, you can find more information at [GitHub Security Bug Bounty](https://bounty.github.com/).

## Security Updates

We are committed to maintaining the security of this project. When a vulnerability is confirmed, we will:

- **Acknowledge receipt of your report**: Confirm that we have received and are investigating the issue.
- **Work to resolve the vulnerability**: Develop and test a fix for the reported issue.
- **Release a patch**: Publish a new version of the project with the fix included.
- **Notify the community**: Announce the fix in our release notes and update the documentation as necessary.

## Best Practices

While we work on security improvements, we recommend that users follow these best practices:

- Keep your dependencies up to date.
- Regularly review your code and configurations for security vulnerabilities.
- Follow security guidelines and best practices relevant to your project.

## Additional Resources

For more information on security practices, you may find these resources helpful:

- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)
- [GitHub Security Advisories](https://docs.github.com/en/code-security/supply-chain-security/working-with-security-advisories/about-security-advisories)
- [CVE Details](https://www.cvedetails.com/)

If you have any questions or need further assistance, please contact us at [security@yourdomain.com](mailto:security@yourdomain.com).

Thank you for helping us keep this project secure!



================================================
File: babel.config.js
================================================
module.exports = {
  presets: [
    '@babel/preset-env',
    '@babel/preset-react',
    '@babel/preset-typescript',
  ],
};



================================================
File: commitlint.config.js
================================================
module.exports = {
  extends: ['@commitlint/config-conventional'],
  ignores: [message => message.includes('[skip-commitlint]')],
  rules: {
    'type-enum': [
      2,
      'always',
      ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore'],
    ],
    'subject-empty': [2, 'never'],
    'type-empty': [2, 'never'],
    'subject-full-stop': [2, 'never', '.'],
    'subject-max-length': [2, 'always', 100],
    'subject-case': [0, 'never'],
  },
};



================================================
File: eslint.config.mjs
================================================
import hub from './index.js';
import babelParser from '@babel/eslint-parser';
import tsParser from '@typescript-eslint/parser';
import globals from 'globals';

export default [
  // Use the flat MERN configuration as the base
  hub.configs['flat/mern'],
  {
    ignores: [
      '**/node_modules/**',
      '**/test/**',
      '**/docs-docusaurus/**',
      '**/*.mjs',
    ],
  },
  {
    files: ['**/*.js', '**/*.jsx'],
    languageOptions: {
      parser: babelParser,
      parserOptions: {
        requireConfigFile: false,
        babelOptions: {
          babelrc: false,
          configFile: false,
          presets: ["@babel/preset-env", "@babel/preset-react"],
        },
        ecmaVersion: 2022,
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
      globals: {
        ...globals.builtin,
      },
    },
    rules: {
      // You can override or add specific rules here if needed
      'no-unused-vars': [
        'error',
        {
          vars: 'all',
          args: 'none',
          ignoreRestSiblings: false,
        },
      ],
    },
  },
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
        project: './tsconfig.json',
      },
      globals: {
        ...globals.builtin,
      },
    },
    // You can add TypeScript-specific rules here if needed
  },
];


================================================
File: index.d.ts
================================================
import type { ESLint, Linter } from 'eslint';

declare module '@mindfiredigital/eslint-plugin-hub' {
  // Type for individual rule
  export interface ESLintRule extends Linter.RuleEntry {
    meta?: {
      docs?: {
        description?: string;
        category?: string;
        recommended?: boolean;
        url?: string;
      };
      schema?: object[];
      messages?: Record<string, string>;
    };
  }

  // General rules
  export const generalRules: Record<string, ESLintRule>;

  // React rules
  export const reactRules: Record<string, ESLintRule>;

  // Angular rules
  export const angularRules: Record<string, ESLintRule>;

  // Flat and legacy configurations
  export const flatConfigBase: ESLint.ConfigData;

  export const legacyConfigBase: ESLint.ConfigData;

  // MERN Recommended Rules (Legacy)
  export const mernRecommendedRulesLegacy: Record<
    string,
    Linter.RuleLevel | Linter.RuleLevelAndOptions
  >;

  // MERN Recommended Rules (Flat Config)
  export const mernRecommendedRulesFlat: Record<
    string,
    Linter.RuleLevel | Linter.RuleLevelAndOptions
  >;

  // The hub object with meta and rules
  export const hub: {
    meta: {
      name: string;
      version: string;
    };
    rules: Record<string, ESLintRule>;
  };

  // Configurations for flat and legacy formats
  export const configs: {
    all: ESLint.ConfigData;
    general: ESLint.ConfigData;
    react: ESLint.ConfigData;
    angular: ESLint.ConfigData;
    mern: ESLint.ConfigData;
    'flat/all': ESLint.ConfigData;
    'flat/general': ESLint.ConfigData;
    'flat/react': ESLint.ConfigData;
    'flat/angular': ESLint.ConfigData;
    'flat/mern': ESLint.ConfigData;
  };
}



================================================
File: index.js
================================================
const generalRules = require('./lib/rules/general/index.js');
const reactRules = require('./lib/rules/react/index.js');
const angularRules = require('./lib/rules/angular/index.js');
const advancedRules = require('./lib/rules/advanced/index.js');
const flatConfigBase = require('./configs/flat-config-base.js');
const legacyConfigBase = require('./configs/legacy-config-base.js');
const expressRules = require('./lib/rules/node/express/open-api-spec/index.js');
const { name, version } = require('./package.json');

// Helper function to convert rule definitions to rule configurations for legacy config
const convertRulesToLegacyConfig = rules => {
  const config = {};
  Object.entries(rules).forEach(([key, rule]) => {
    config[`@mindfiredigital/hub/${key}`] = ['error', rule];
  });
  return config;
};

// Helper function to convert rule definitions to rule configurations for flat config
const convertRulesToFlatConfig = rules => {
  const config = {};
  Object.entries(rules).forEach(([key]) => {
    config[`hub/${key}`] = 'error';
  });
  return config;
};

// Recommended rules for MERN in legacy (with @mindfiredigital prefix)
const mernRecommendedRulesLegacy = {
  '@mindfiredigital/hub/file-kebabcase': 'error',
  '@mindfiredigital/hub/vars-camelcase': 'error',
  '@mindfiredigital/hub/class-pascalcase': 'error',
  '@mindfiredigital/hub/function-camelcase': 'error',
  '@mindfiredigital/hub/function-descriptive': 'warn',
  '@mindfiredigital/hub/react-component-name-match-filename': 'error',
  '@mindfiredigital/hub/react-filename-pascalcase': 'error',
};

// Recommended rules for MERN in flat config (no need for @mindfiredigital prefix)
const mernRecommendedRulesFlat = {
  'hub/file-kebabcase': 'error',
  'hub/vars-camelcase': 'error',
  'hub/class-pascalcase': 'error',
  'hub/function-camelcase': 'error',
  'hub/function-descriptive': 'warn',
  'hub/react-component-name-match-filename': 'error',
  'hub/react-filename-pascalcase': 'error',
};

// Create configuration (legacy or flat)
const createConfig = (rules, flatConfigName = false) => ({
  ...(flatConfigName
    ? { ...flatConfigBase, name: flatConfigName, plugins: { hub } }
    : { ...legacyConfigBase, plugins: ['@mindfiredigital/eslint-plugin-hub'] }),
  rules: { ...rules },
});

// Define the hub object with meta information and rules
const hub = {
  meta: {
    name,
    version,
  },
  rules: {
    ...generalRules.rules,
    ...reactRules.rules,
    ...angularRules.rules,
    ...advancedRules.rules,
    ...expressRules.rules,
  },
};

// Configurations for flat and legacy, including recommended rules
const configs = {
  // Legacy format configurations
  all: createConfig(convertRulesToLegacyConfig(hub.rules)),
  general: createConfig(convertRulesToLegacyConfig(generalRules.rules)),
  react: createConfig(convertRulesToLegacyConfig(reactRules.rules)),
  angular: createConfig(convertRulesToLegacyConfig(angularRules.rules)),
  advanced: createConfig(convertRulesToLegacyConfig(advancedRules.rules)),
  express: createConfig(convertRulesToLegacyConfig(expressRules.rules)),
  mern: createConfig(mernRecommendedRulesLegacy),

  // Flat format configurations
  'flat/all': createConfig(convertRulesToFlatConfig(hub.rules), 'hub/flat/all'),
  'flat/general': createConfig(
    convertRulesToFlatConfig(generalRules.rules),
    'hub/flat/general'
  ),
  'flat/react': createConfig(
    convertRulesToFlatConfig(reactRules.rules),
    'hub/flat/react'
  ),
  'flat/angular': createConfig(
    convertRulesToFlatConfig(angularRules.rules),
    'hub/flat/angular'
  ),
  'flat/advanced': createConfig(
    convertRulesToFlatConfig(advancedRules.rules),
    'hub/flat/advanced'
  ),

  'flat/express': createConfig(
    convertRulesToFlatConfig(expressRules.rules),
    'hub/flat/express'
  ),

  'flat/mern': createConfig(mernRecommendedRulesFlat, 'hub/flat/mern'),
};

// Export the hub and its configurations
module.exports = { ...hub, configs };



================================================
File: index.mjs
================================================
/* eslint-disable hub/vars-camelcase */
import generalRules from './lib/rules/general/index.js';
import reactRules from './lib/rules/react/index.js';
import angularRules from './lib/rules/angular/index.js';
import advancedRules from './lib/rules/advanced/index.js';

import expressRules from './lib/rules/node/express/open-api-spec/index.js';

import flatConfigBase from './configs/flat-config-base.mjs';
import legacyConfigBase from './configs/legacy-config-base.mjs';

import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { readFileSync } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const packageJson = JSON.parse(
  readFileSync(join(__dirname, 'package.json'), 'utf8')
);

// Helper function to convert rule definitions to rule configurations for legacy config
const convertRulesToLegacyConfig = rules => {
  const config = {};
  Object.entries(rules).forEach(([key, rule]) => {
    config[`@mindfiredigital/hub/${key}`] = ['error', rule];
  });
  return config;
};

// Helper function to convert rule definitions to rule configurations for flat config
const convertRulesToFlatConfig = rules => {
  const config = {};
  Object.entries(rules).forEach(([key]) => {
    config[`hub/${key}`] = 'error';
  });
  return config;
};

// Recommended rules for MERN in legacy (with @mindfiredigital prefix)
const mernRecommendedRulesLegacy = {
  '@mindfiredigital/hub/file-kebabcase': 'error',
  '@mindfiredigital/hub/vars-camelcase': 'error',
  '@mindfiredigital/hub/class-pascalcase': 'error',
  '@mindfiredigital/hub/function-camelcase': 'error',
  '@mindfiredigital/hub/function-descriptive': 'warn',
  '@mindfiredigital/hub/react-component-name-match-filename': 'error',
  '@mindfiredigital/hub/react-filename-pascalcase': 'error',
};

// Recommended rules for MERN in flat config (no need for @mindfiredigital prefix)
const mernRecommendedRulesFlat = {
  'hub/file-kebabcase': 'error',
  'hub/vars-camelcase': 'error',
  'hub/class-pascalcase': 'error',
  'hub/function-camelcase': 'error',
  'hub/function-descriptive': 'warn',
  'hub/react-component-name-match-filename': 'error',
  'hub/react-filename-pascalcase': 'error',
};

// Create configuration (legacy or flat)
const createConfig = (rules, flatConfigName = false) => ({
  ...(flatConfigName
    ? { ...flatConfigBase, name: flatConfigName, plugins: { hub } }
    : { ...legacyConfigBase, plugins: ['@mindfiredigital/eslint-plugin-hub'] }),
  rules: { ...rules },
});

// Define the hub object with meta information and rules
const hub = {
  meta: {
    name: packageJson.name,
    version: packageJson.version,
  },
  rules: {
    ...generalRules.rules,
    ...reactRules.rules,
    ...angularRules.rules,
    ...advancedRules.rules,
    ...expressRules.rules,
  },
};

// Configurations for flat and legacy, including recommended rules
const configs = {
  // Legacy format configurations
  all: createConfig(convertRulesToLegacyConfig(hub.rules)),
  general: createConfig(convertRulesToLegacyConfig(generalRules.rules)),
  react: createConfig(convertRulesToLegacyConfig(reactRules.rules)),
  angular: createConfig(convertRulesToLegacyConfig(angularRules.rules)),
  advanced: createConfig(convertRulesToLegacyConfig(advancedRules.rules)),
  express: createConfig(convertRulesToLegacyConfig(expressRules.rules)),
  mern: createConfig(mernRecommendedRulesLegacy),

  // Flat format configurations
  'flat/all': createConfig(convertRulesToFlatConfig(hub.rules), 'hub/flat/all'),
  'flat/general': createConfig(
    convertRulesToFlatConfig(generalRules.rules),
    'hub/flat/general'
  ),
  'flat/react': createConfig(
    convertRulesToFlatConfig(reactRules.rules),
    'hub/flat/react'
  ),
  'flat/angular': createConfig(
    convertRulesToFlatConfig(angularRules.rules),
    'hub/flat/angular'
  ),
  'flat/advanced': createConfig(convertRulesToFlatConfig(advancedRules.rules), 'hub/flat/advanced'),

  'flat/express': createConfig(convertRulesToFlatConfig(expressRules.rules), 'hub/flat/express'),
  
  'flat/mern': createConfig(mernRecommendedRulesFlat, 'hub/flat/mern'),
};

// Export the hub and its configurations
export { hub, configs };
export default { ...hub, configs };



================================================
File: jest.config.js
================================================
module.exports = {
  transform: {
    '^.+\\.(js|jsx|ts|tsx|mjs)$': 'babel-jest', // Combine the two transform rules
  },
  testEnvironment: 'node',
  verbose: true,
  moduleFileExtensions: ['js', 'jsx', 'ts', 'tsx', 'json', 'node', 'mjs'],
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  maxWorkers: 1,
};



================================================
File: package.json
================================================
{
  "name": "@mindfiredigital/eslint-plugin-hub",
  "version": "1.0.0-development",
  "description": "eslint-plugin-hub is a powerful, flexible ESLint plugin that provides a curated set of rules to enhance code readability, maintainability, and prevent common errors. Whether you're working with vanilla JavaScript, TypeScript, React, or Angular, eslint-plugin-hub has you covered with ecosystem-specific rules and general best practices.",
  "repository": {
    "type": "git",
    "url": "https://github.com/mindfiredigital/eslint-plugin-hub.git"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/",
    "access": "public"
  },
  "main": "index.js",
  "module": "./index.mjs",
  "types": "index.d.ts",
  "sideEffects": false,
  "scripts": {
    "test": "jest",
    "lint": "eslint .",
    "prepare": "husky",
    "generate-rule": "node script/generate-rule.js",
    "postinstall": "node lib/utils/check-eslint-config.js"
  },
  "keywords": [
    "eslint",
    "eslint-plugin",
    "eslintplugin",
    "hub",
    "eslint-plugin-react",
    "eslint-plugin-angular",
    "eslint-plugin-typescript",
    "eslint-plugin-advanced",
    "eslint-plugin-js",
    "coding-standards",
    "pluginHub",
    "linter",
    "lint",
    "react",
    "angular",
    "node",
    "mern",
    "typescript",
    "javascript",
    "code-quality",
    "frontend",
    "backend",
    "custom-rules",
    "camelcase",
    "kebabcase",
    "pascalcase",
    "function-naming"
  ],
  "author": "mindfiredigital",
  "license": "MIT",
  "files": [
    "configs/",
    "lib/",
    "index.js",
    "index.mjs",
    "index.d.ts",
    "package.json",
    "tsconfig.json",
    "babel.config.js",
    "README.md",
    "LICENSE.md"
  ],
  "dependencies": {
    "@babel/parser": "^7.21.0",
    "@babel/traverse": "^7.21.0",
    "@babel/types": "^7.21.0",
    "@typescript-eslint/typescript-estree": "^5.0.1",
    "compromise": "^14.0.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.25.1",
    "@babel/preset-env": "^7.25.4",
    "@babel/preset-react": "^7.24.7",
    "@babel/preset-typescript": "^7.24.7",
    "@commitlint/cli": "^19.4.0",
    "@commitlint/config-conventional": "^19.2.2",
    "@typescript-eslint/parser": "^8.5.0",
    "babel-jest": "^29.7.0",
    "compromise": "^14.14.0",
    "eslint": "^9.10.0",
    "globals": "^15.9.0",
    "husky": "^9.1.5",
    "jest": "^29.7.0",
    "lint-staged": "^15.2.9",
    "prettier": "^3.3.3",
    "semantic-release": "^24.1.1",
    "typescript": "^5.8.3"
  },
  "peerDependencies": {
    "eslint": ">=8.56.0"
  },
  "lint-staged": {
    "**/*.{js,ts}": [
      "prettier --write",
      "eslint ."
    ],
    "**/*.json": [
      "prettier --write"
    ],
    "**/*.md": [
      "prettier --write"
    ]
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "release": {
    "repositoryUrl": "https://github.com/mindfiredigital/eslint-plugin-hub.git",
    "branches": [
      "master",
      "next",
      {
        "name": "beta",
        "prerelease": true
      }
    ]
  }
}



================================================
File: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"],
  "exclude": ["node_modules"]
}



================================================
File: .npmignore
================================================
# Exclude everything by default
*

# Allow specific files and folders to be included
!configs
!lib/
!index.js
!package.json
!tsconfig.json
!babel.config.js
!eslint.config.mjs

# Optional: You can explicitly ignore other config files or directories if needed
# Ignore test files
tests/
*.test.js

# Ignore node_modules if it's not already excluded
node_modules/



================================================
File: .prettierignore
================================================
node_modules/


================================================
File: .prettierrc
================================================
{
    "printWidth": 80,
    "tabWidth": 2,
    "useTabs": false,
    "semi": true,
    "singleQuote": true,
    "trailingComma": "es5",
    "bracketSpacing": true,
    "arrowParens": "avoid",
    "endOfLine": "auto"
  }
  


================================================
File: configs/flat-config-base.js
================================================
'use strict';
const globals = require('globals');

module.exports = {
  languageOptions: {
    globals: globals.builtin,
  },
};



================================================
File: configs/legacy-config-base.js
================================================
'use strict';
module.exports = {
  env: {
    es2024: true,
  },
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
};



================================================
File: lib/rules/advanced/index.js
================================================
const limitDataScope = require('./plugin/limit-data-scope');
const keepFunctionsConcise = require('./plugin/keep-functions-concise');
const fixedLoopBounds = require('./plugin/fixed-loop-bounds');
const limitReferenceDepth = require('./plugin/limit-reference-depth');
const checkReturnValues = require('./plugin/check-return-values');
const minimizeComplexflows = require('./plugin/minimize-complexflows');
const avoidRuntimeHeapAllocation = require('./plugin/avoid-runtime-heap-allocation');
const useRuntimeAssesrtion = require('./plugin/use-runtime-assertions');
const minimizeDeepAsynchronousChains = require('./plugin/minimize-deep-asynchronous-chains');

module.exports = {
  rules: {
    ...limitDataScope.rules,
    ...keepFunctionsConcise.rules,
    ...fixedLoopBounds.rules,
    ...limitReferenceDepth.rules,
    ...checkReturnValues.rules,
    ...minimizeComplexflows.rules,
    ...avoidRuntimeHeapAllocation.rules,
    ...useRuntimeAssesrtion.rules,
    ...minimizeDeepAsynchronousChains.rules,
  },
};



================================================
File: lib/rules/advanced/plugin/avoid-runtime-heap-allocation.js
================================================
module.exports = {
  rules: {
    'avoid-runtime-heap-allocation': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Discourages heap allocation of common data structures (arrays, objects, Maps, Sets) within function bodies, especially in loops, to promote reuse of pre-allocated structures and reduce garbage collection pressure.',
          recommended: 'warn',
          url: '', // TODO: Add a URL to your rule's documentation
        },
        messages: {
          allocationInFunction:
            "Runtime allocation of '{{constructType}}' ({{nodeText}}) detected in function '{{functionName}}'. Consider pre-allocating and reusing, especially if this function is called frequently or is performance-sensitive.",
          allocationInLoop:
            "Runtime allocation of '{{constructType}}' ({{nodeText}}) detected inside a loop within function '{{functionName}}'. This can severely impact performance. Pre-allocate and reuse this structure.",
        },
        schema: [
          {
            type: 'object',
            properties: {
              checkLoopsOnly: {
                type: 'boolean',
                default: false,
                description:
                  'If true, only flags allocations found inside loops within functions.',
              },
              allowedConstructs: {
                type: 'array',
                items: {
                  type: 'string',
                  enum: ['Array', 'Object', 'Map', 'Set', 'WeakMap', 'WeakSet'],
                },
                default: [],
                description:
                  "List of constructor names (e.g., 'Map', 'Set') to allow even if allocated at runtime within functions/loops.",
              },
            },
            additionalProperties: false,
          },
        ],
        fixable: null,
      },
      create(context) {
        const options = context.options[0] || {};
        const checkLoopsOnly = options.checkLoopsOnly ?? false;
        const allowedConstructs = new Set(options.allowedConstructs || []);

        const sourceCode = context.getSourceCode();

        const functionStack = [];
        let loopDepth = 0;

        function getFunctionName(node) {
          if (node.type === 'FunctionDeclaration' && node.id) {
            return node.id.name;
          }
          if (
            node.type === 'FunctionExpression' ||
            node.type === 'ArrowFunctionExpression'
          ) {
            if (
              node.parent.type === 'VariableDeclarator' &&
              node.parent.id &&
              node.parent.id.type === 'Identifier'
            ) {
              return node.parent.id.name;
            }
            if (
              node.parent.type === 'MethodDefinition' &&
              node.parent.key &&
              node.parent.key.type === 'Identifier'
            ) {
              return node.parent.key.name;
            }
            if (
              node.parent.type === 'Property' &&
              node.parent.key &&
              node.parent.key.type === 'Identifier'
            ) {
              return node.parent.key.name;
            }
          }
          return '<anonymous>';
        }

        function reportAllocation(node, constructType) {
          if (allowedConstructs.has(constructType)) {
            return;
          }
          if (functionStack.length === 0) {
            return; // Not inside a function (module scope)
          }

          const currentFunctionName = functionStack[functionStack.length - 1];
          const nodeTextFull = sourceCode.getText(node);
          const nodeText =
            nodeTextFull.length > 25
              ? nodeTextFull.slice(0, 25) + '...'
              : nodeTextFull;

          if (loopDepth > 0) {
            context.report({
              node,
              messageId: 'allocationInLoop',
              data: {
                constructType,
                nodeText,
                functionName: currentFunctionName,
              },
            });
          } else if (!checkLoopsOnly) {
            context.report({
              node,
              messageId: 'allocationInFunction',
              data: {
                constructType,
                nodeText,
                functionName: currentFunctionName,
              },
            });
          }
        }

        return {
          ':function'(node) {
            functionStack.push(getFunctionName(node));
          },
          ':function:exit'() {
            functionStack.pop();
          },

          ForStatement() {
            loopDepth++;
          },
          ForInStatement() {
            loopDepth++;
          },
          ForOfStatement() {
            loopDepth++;
          },
          WhileStatement() {
            loopDepth++;
          },
          DoWhileStatement() {
            loopDepth++;
          },
          'ForStatement:exit'() {
            loopDepth--;
          },
          'ForInStatement:exit'() {
            loopDepth--;
          },
          'ForOfStatement:exit'() {
            loopDepth--;
          },
          'WhileStatement:exit'() {
            loopDepth--;
          },
          'DoWhileStatement:exit'() {
            loopDepth--;
          },

          ArrayExpression(node) {
            if (
              node.elements.length === 0 &&
              node.parent &&
              node.parent.type === 'AssignmentPattern' &&
              node.parent.right === node
            ) {
              return;
            }
            reportAllocation(node, 'Array');
          },
          ObjectExpression(node) {
            if (
              node.properties.length === 0 &&
              node.parent &&
              node.parent.type === 'AssignmentPattern' &&
              node.parent.right === node
            ) {
              return;
            }
            reportAllocation(node, 'Object');
          },
          NewExpression(node) {
            if (node.callee.type === 'Identifier') {
              const constructorName = node.callee.name;
              if (
                [
                  'Array',
                  'Object',
                  'Map',
                  'Set',
                  'WeakMap',
                  'WeakSet',
                ].includes(constructorName)
              ) {
                reportAllocation(node, constructorName);
              }
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/advanced/plugin/check-return-values.js
================================================
'use strict';

const consoleMethods = new Set([
  'log',
  'warn',
  'error',
  'info',
  'debug',
  'table',
  'trace',
  'dir',
  'dirxml',
  'group',
  'groupCollapsed',
  'groupEnd',
  'time',
  'timeLog',
  'timeEnd',
  'clear',
  'count',
  'countReset',
  'assert',
  'profile',
  'profileEnd',
  'timeStamp',
]);
const functionMap = new Map();

module.exports = {
  rules: {
    'check-return-values': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforce handling of return values from non-void functions. If the return value is intentionally not used, it should be explicitly ignored.',
          category: 'Best Practices',
          recommended: false,
        },
        fixable: null,
        schema: [
          {
            type: 'object',
            properties: {
              requireExplicitIgnore: {
                type: 'boolean',
                default: true,
              },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          returnValueNotHandled:
            "Return value of function '{{functionName}}' should be handled or explicitly ignored.",
        },
      },
      create: function (context) {
        const sourceCode = context.getSourceCode();
        const parserServices = context.parserServices;
        const checker = parserServices?.program?.getTypeChecker();

        function collectFunctionDeclarations(node) {
          if (node.type === 'FunctionDeclaration' && node.id?.name) {
            functionMap.set(node.id.name, node);
          }
        }

        function hasReturnWithValue(node, seen = new WeakSet(), depth = 0) {
          // Safety checks
          if (!node || typeof node !== 'object' || depth > 100) {
            return false;
          }

          // Prevent circular references
          if (seen.has(node)) {
            return false;
          }
          seen.add(node);

          try {
            // Check if current node is a return statement with a value
            if (node.type === 'ReturnStatement' && node.argument) {
              return true;
            }

            // Only check properties that are likely to contain AST nodes
            const keys = Object.keys(node);
            for (const key of keys) {
              // Skip certain properties that might cause issues
              if (
                key === 'parent' ||
                key === 'loc' ||
                key === 'range' ||
                key === 'comments'
              ) {
                continue;
              }

              const value = node[key];

              if (Array.isArray(value)) {
                for (const child of value) {
                  if (
                    child &&
                    typeof child === 'object' &&
                    hasReturnWithValue(child, seen, depth + 1)
                  ) {
                    return true;
                  }
                }
              } else if (value && typeof value === 'object') {
                if (hasReturnWithValue(value, seen, depth + 1)) {
                  return true;
                }
              }
            }

            return false;
          } finally {
            // Clean up to avoid memory leaks
            seen.delete(node);
          }
        }

        function getFunctionName(callExprNode) {
          const callee = callExprNode.callee;
          if (callee.type === 'Identifier') {
            return callee.name;
          }
          if (callee.type === 'MemberExpression') {
            return sourceCode.getText(callee);
          }
          // Avoid overly complex names for IIFEs or deeply nested calls in the message
          if (
            callee.type === 'FunctionExpression' ||
            callee.type === 'ArrowFunctionExpression'
          ) {
            return callee.id ? callee.id.name : '(anonymous function)';
          }
          return sourceCode.getText(callee).slice(0, 50); // Cap length for very long textual representations
        }

        function isConsoleCall(node) {
          const callee = node.callee;
          return (
            callee.type === 'MemberExpression' &&
            callee.object.type === 'Identifier' &&
            callee.object.name === 'console' &&
            callee.property.type === 'Identifier' &&
            consoleMethods.has(callee.property.name)
          );
        }

        return {
          FunctionDeclaration: collectFunctionDeclarations,

          CallExpression(node) {
            const parent = node.parent;

            // First check TypeScript return type if available
            if (checker && parserServices) {
              const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
              const signature = checker.getResolvedSignature(tsNode);
              const returnType =
                signature && checker.getReturnTypeOfSignature(signature);
              if (returnType && checker.typeToString(returnType) === 'void') {
                // Skip checks for explicitly void functions
                return;
              }
            }

            if (node.callee.type === 'Identifier') {
              const fn = functionMap.get(node.callee.name);
              if (fn && fn.body) {
                // Skip return value checks for functions without return statements
                const hasReturns = hasReturnWithValue(fn.body);
                if (!hasReturns) {
                  // If no return statements, treat as void function and skip further checks
                  return;
                }
                // Only continue with return value checks if there are actual returns
              }
            }

            // 1. Check if the return value is "used" in common ways
            if (
              (parent.type === 'VariableDeclarator' && parent.init === node) ||
              (parent.type === 'AssignmentExpression' &&
                parent.right === node &&
                !(
                  parent.left.type === 'Identifier' && parent.left.name === '_'
                )) ||
              (parent.type === 'Property' && parent.value === node) ||
              (parent.type === 'ReturnStatement' && parent.argument === node) ||
              (parent.type === 'ArrowFunctionExpression' &&
                parent.body === node) || // Implicit return
              (parent.type === 'ConditionalExpression' &&
                (parent.test === node ||
                  parent.consequent === node ||
                  parent.alternate === node)) ||
              (parent.type === 'IfStatement' && parent.test === node) ||
              (parent.type === 'SwitchStatement' &&
                parent.discriminant === node) ||
              (parent.type === 'CallExpression' &&
                parent.arguments.includes(node)) ||
              (parent.type === 'NewExpression' &&
                parent.arguments.includes(node)) ||
              (parent.type === 'ArrayExpression' &&
                parent.elements.includes(node)) ||
              parent.type === 'BinaryExpression' || // e.g., x + foo(), foo() > 0
              parent.type === 'LogicalExpression' || // e.g., foo() && bar()
              (parent.type === 'UnaryExpression' &&
                parent.operator !== 'void') || // e.g., !foo(), await foo() but not void foo()
              parent.type === 'UpdateExpression' || // e.g. ++foo()
              parent.type === 'YieldExpression' || // e.g. yield foo()
              parent.type === 'AwaitExpression' || // e.g. await foo()
              parent.type === 'TaggedTemplateExpression' || // e.g. a` ${foo()} `
              parent.type === 'SpreadElement' // e.g. [...foo()]
            ) {
              return;
            }

            // 2. Check for explicit `void` operator
            if (
              parent.type === 'UnaryExpression' &&
              parent.operator === 'void' &&
              parent.argument === node
            ) {
              return;
            }

            // 3. Check for explicit ignore: `_ = foo();` as a statement
            if (
              parent.type === 'AssignmentExpression' &&
              parent.right === node &&
              parent.left.type === 'Identifier' &&
              parent.left.name === '_' &&
              parent.parent.type === 'ExpressionStatement' &&
              parent.parent.expression === parent
            ) {
              return;
            }

            // 4. If we reach here, the CallExpression's value might be discarded.
            // This typically happens if it's the main expression in an ExpressionStatement.
            if (
              parent.type === 'ExpressionStatement' &&
              parent.expression === node
            ) {
              // 4a. Exempt console calls
              if (isConsoleCall(node)) {
                return;
              }

              // 4c. Check for ignoring comments
              let commentIgnored = false;
              const statementNode = parent; // The ExpressionStatement

              // Check for a comment on the line immediately preceding the statement
              const commentsBefore =
                sourceCode.getCommentsBefore(statementNode);
              for (const comment of commentsBefore) {
                if (
                  comment.value.trim().toLowerCase() ===
                    'return value intentionally ignored' &&
                  comment.loc.end.line === statementNode.loc.start.line - 1
                ) {
                  commentIgnored = true;
                  break;
                }
              }

              if (!commentIgnored) {
                // Check for a trailing comment on the same line as the CallExpression's statement
                const commentsInStatement =
                  sourceCode.getCommentsInside(statementNode);
                const trailingComments =
                  sourceCode.getCommentsAfter(statementNode);
                const allPotentialTrailingComments = [
                  ...commentsInStatement,
                  ...trailingComments,
                ];

                for (const comment of allPotentialTrailingComments) {
                  // Ensure comment is on the same line the statement ends or CallExpression ends
                  if (
                    comment.loc.start.line === statementNode.loc.end.line ||
                    comment.loc.start.line === node.loc.end.line
                  ) {
                    if (
                      comment.value.trim().toLowerCase() ===
                      'return value intentionally ignored'
                    ) {
                      commentIgnored = true;
                      break;
                    }
                  }
                }
              }

              if (!commentIgnored) {
                context.report({
                  node: node,
                  messageId: 'returnValueNotHandled',
                  data: { functionName: getFunctionName(node) },
                });
              }
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/advanced/plugin/fixed-loop-bounds.js
================================================
/**
 * Checks if an identifier is reassigned or updated within a given AST node (loop body).
 * @param {string} identifierName - The name of the identifier to check.
 * @param {ASTNode} loopBodyNode - The AST node representing the loop's body.
 * @returns {boolean} - True if the identifier is modified, false otherwise.
 */
function isIdentifierModifiedInBody(identifierName, loopBodyNode) {
  let isModified = false;

  function traverse(node) {
    if (isModified) return; // Optimization

    if (node.type === 'AssignmentExpression') {
      if (
        node.left.type === 'Identifier' &&
        node.left.name === identifierName
      ) {
        isModified = true;
        return;
      }
      // Could also check MemberExpression for obj.prop = value if flag is a property
    } else if (node.type === 'UpdateExpression') {
      if (
        node.argument.type === 'Identifier' &&
        node.argument.name === identifierName
      ) {
        isModified = true;
        return;
      }
    }

    // Do not traverse into nested functions, as their modifications are in a different scope
    if (
      node.type === 'FunctionDeclaration' ||
      node.type === 'FunctionExpression' ||
      node.type === 'ArrowFunctionExpression'
    ) {
      return;
    }

    for (const key in node) {
      if (node.hasOwnProperty(key) && key !== 'parent') {
        const child = node[key];
        if (typeof child === 'object' && child !== null) {
          if (Array.isArray(child)) {
            child.forEach(traverse);
          } else {
            traverse(child);
          }
        }
      }
    }
  }

  if (loopBodyNode) {
    traverse(loopBodyNode);
  }
  return isModified;
}

/**
 * Checks if a loop has an effective break statement targeting it.
 * @param {ASTNode} loopNode - The AST node representing the loop.
 * @returns {boolean} - True if an effective break is found, false otherwise.
 */
function hasEffectiveBreak(loopNode) {
  let foundBreak = false;

  function traverse(node) {
    if (foundBreak) return;

    if (
      node.type === 'FunctionDeclaration' ||
      node.type === 'FunctionExpression' ||
      node.type === 'ArrowFunctionExpression'
    ) {
      return; // Breaks in nested functions do not affect the outer loop
    }

    if (node.type === 'BreakStatement') {
      if (node.label) {
        // If break has a label, check if it matches a label of the loopNode or its ancestors
        let parent = loopNode.parent;
        while (parent) {
          if (
            parent.type === 'LabeledStatement' &&
            parent.label.name === node.label.name
          ) {
            if (parent.body === loopNode) {
              foundBreak = true;
            }
            return; // Found the label target
          }
          parent = parent.parent;
        }
      } else {
        // No label, break targets the innermost enclosing loop or switch
        let current = node.parent;
        while (current) {
          if (current === loopNode) {
            foundBreak = true; // This break targets our loopNode
            break;
          }
          // If we hit an *inner* loop or switch before loopNode, this break is for that
          if (
            current.type === 'ForStatement' ||
            current.type === 'ForInStatement' ||
            current.type === 'ForOfStatement' ||
            current.type === 'WhileStatement' ||
            current.type === 'DoWhileStatement' ||
            current.type === 'SwitchStatement'
          ) {
            break; // Break belongs to an inner construct
          }
          current = current.parent;
        }
      }
      return;
    }

    for (const key in node) {
      if (node.hasOwnProperty(key) && key !== 'parent') {
        const child = node[key];
        if (typeof child === 'object' && child !== null) {
          if (Array.isArray(child)) {
            child.forEach(traverse);
          } else {
            traverse(child);
          }
        }
      }
    }
  }
  if (loopNode.body) {
    traverse(loopNode.body);
  }
  return foundBreak;
}

module.exports.rules = {
  'fixed-loop-bounds': {
    meta: {
      type: 'problem',
      docs: {
        description:
          'Enforce that loops have clearly defined termination conditions to prevent infinite loops.',
        category: 'Best Practices',
        recommended: false, // Or true, depending on project preference
      },
      fixable: null,
      schema: [
        {
          type: 'object',
          properties: {
            disallowInfiniteWhile: {
              type: 'boolean',
              default: true,
            },
            disallowExternalFlagLoops: {
              type: 'boolean',
              default: true,
            },
          },
          additionalProperties: false,
        },
      ],
      messages: {
        infiniteWhileTrueLoop:
          'Potentially infinite `while(true)` loop detected without an effective `break` or `return` statement.',
        infiniteDoWhileTrueLoop:
          'Potentially infinite `do...while(true)` loop detected without an effective `break` or `return` statement.',
        infiniteForLoopNoTest:
          'Potentially infinite `for` loop (no test condition) detected without an effective `break` or `return` statement.',
        infiniteForLoopTrueTest:
          'Potentially infinite `for` loop (test condition is `true`) detected without an effective `break` or `return` statement.',
        externalFlagWhileLoop:
          'Loop condition flag `{{flagName}}` in `while` statement does not appear to be modified within the loop body.',
        externalFlagDoWhileLoop:
          'Loop condition flag `{{flagName}}` in `do...while` statement does not appear to be modified within the loop body.',
      },
    },
    create: function (context) {
      const options = context.options[0] || {};
      const disallowInfiniteWhile = options.disallowInfiniteWhile !== false;
      const disallowExternalFlagLoops =
        options.disallowExternalFlagLoops !== false;

      function checkLoopConditionFlag(node, testNode, messageIdPrefix) {
        let flagIdentifierNode = null;
        if (testNode.type === 'Identifier') {
          flagIdentifierNode = testNode;
        } else if (
          testNode.type === 'UnaryExpression' &&
          testNode.operator === '!' &&
          testNode.argument.type === 'Identifier'
        ) {
          flagIdentifierNode = testNode.argument;
        }

        if (flagIdentifierNode) {
          if (!isIdentifierModifiedInBody(flagIdentifierNode.name, node.body)) {
            context.report({
              node: testNode,
              messageId: `externalFlag${messageIdPrefix.charAt(0).toUpperCase() + messageIdPrefix.slice(1)}Loop`,
              data: { flagName: flagIdentifierNode.name },
            });
          }
        }
      }

      return {
        WhileStatement(node) {
          if (node.test) {
            if (
              disallowInfiniteWhile &&
              node.test.type === 'Literal' &&
              node.test.value === true
            ) {
              if (!hasEffectiveBreak(node)) {
                context.report({
                  node: node.test,
                  messageId: 'infiniteWhileTrueLoop',
                });
              }
            } else if (disallowExternalFlagLoops) {
              checkLoopConditionFlag(node, node.test, 'while');
            }
          }
        },
        DoWhileStatement(node) {
          if (node.test) {
            if (
              disallowInfiniteWhile &&
              node.test.type === 'Literal' &&
              node.test.value === true
            ) {
              // do-while always executes at least once, break can be inside
              if (!hasEffectiveBreak(node)) {
                context.report({
                  node: node.test,
                  messageId: 'infiniteDoWhileTrueLoop',
                });
              }
            } else if (disallowExternalFlagLoops) {
              checkLoopConditionFlag(node, node.test, 'doWhile');
            }
          }
        },
        ForStatement(node) {
          if (disallowInfiniteWhile) {
            if (!node.test) {
              // e.g., for (;;)
              if (!hasEffectiveBreak(node)) {
                context.report({ node, messageId: 'infiniteForLoopNoTest' });
              }
            } else if (
              node.test.type === 'Literal' &&
              node.test.value === true
            ) {
              if (!hasEffectiveBreak(node)) {
                context.report({
                  node: node.test,
                  messageId: 'infiniteForLoopTrueTest',
                });
              }
            }
          }
        },
      };
    },
  },
};



================================================
File: lib/rules/advanced/plugin/keep-functions-concise.js
================================================
/**
 * Gets the name of a function node.
 * @param {ASTNode} node The function node.
 * @returns {string} The name of the function or '[anonymous_function]'.
 */
function getFunctionName(node) {
  if (node.id && node.id.name) {
    return node.id.name;
  }
  if (node.parent) {
    if (
      node.parent.type === 'VariableDeclarator' &&
      node.parent.id &&
      node.parent.id.name
    ) {
      return node.parent.id.name;
    }
    if (node.parent.type === 'Property' && node.parent.key) {
      return (
        node.parent.key.name || node.parent.key.value || '[anonymous_function]'
      );
    }
    if (
      node.parent.type === 'AssignmentExpression' &&
      node.parent.left &&
      node.parent.left.name
    ) {
      return node.parent.left.name;
    }
  }
  return '[anonymous_function]';
}

module.exports = {
  rules: {
    'keep-functions-concise': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Enforces a maximum number of lines per function, with options to skip blank lines and comments.',
          category: 'Best Practices',
          recommended: false,
        },
        schema: [
          {
            type: 'object',
            properties: {
              maxLines: {
                type: 'integer',
                minimum: 0,
                default: 60,
              },
              skipBlankLines: {
                type: 'boolean',
                default: false,
              },
              skipComments: {
                type: 'boolean',
                default: false,
              },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          tooManyLines:
            'Function "{{name}}" has {{actualLines}} lines (max {{maxLines}} allowed). {{skippedLineInfo}}',
        },
      },
      create(context) {
        const sourceCode = context.getSourceCode();
        const options = context.options[0] || {};
        const maxLines = options.maxLines !== undefined ? options.maxLines : 60;
        const skipBlankLines =
          options.skipBlankLines !== undefined ? options.skipBlankLines : false;
        const skipComments =
          options.skipComments !== undefined ? options.skipComments : false;

        /**
         * Checks a given function node for line count violations.
         * @param {ASTNode} node - The function node to check.
         */
        function checkFunction(node) {
          // Handle concise arrow functions (not enclosed in a block)
          if (node.body.type !== 'BlockStatement') {
            if (maxLines === 0) {
              context.report({
                node,
                messageId: 'tooManyLines',
                data: {
                  name: getFunctionName(node),
                  actualLines: 1,
                  maxLines: maxLines,
                  skippedLineInfo: `(concise body counted as 1 line)`,
                },
              });
            }
            return;
          }

          const body = node.body;
          const allLines = sourceCode.getLines();
          const startLineIndex = body.loc.start.line;
          const endLineIndex = body.loc.end.line - 2;

          let effectiveLineCount = 0;

          if (startLineIndex <= endLineIndex + 1) {
            for (let i = startLineIndex; i <= endLineIndex; i++) {
              const lineText = allLines[i];
              const trimmedLine = lineText.trim();

              if (skipBlankLines && trimmedLine === '') {
                continue;
              }

              if (skipComments) {
                if (
                  trimmedLine === '' ||
                  trimmedLine.startsWith('//') ||
                  (trimmedLine.startsWith('/*') && trimmedLine.endsWith('*/'))
                ) {
                  const tokensOnLine = sourceCode.getTokens(body, {
                    filter: token =>
                      token.loc.start.line === i + 1 &&
                      token.loc.end.line === i + 1,
                    includeComments: false,
                  });
                  if (tokensOnLine.length === 0) {
                    continue;
                  }
                }
              }
              effectiveLineCount++;
            }
          }

          let skippedLineInfoParts = [];
          if (skipBlankLines) skippedLineInfoParts.push('blank lines skipped');
          if (skipComments) skippedLineInfoParts.push('comment lines skipped');
          const skippedLineInfo =
            skippedLineInfoParts.length > 0
              ? `(${skippedLineInfoParts.join(', ')})`
              : '(no lines skipped by options)';

          if (effectiveLineCount > maxLines) {
            context.report({
              node,
              messageId: 'tooManyLines',
              data: {
                name: getFunctionName(node),
                actualLines: effectiveLineCount,
                maxLines: maxLines,
                skippedLineInfo: skippedLineInfo,
              },
            });
          }
        }

        return {
          FunctionDeclaration: checkFunction,
          FunctionExpression: checkFunction,
          ArrowFunctionExpression: checkFunction,
        };
      },
    },
  },
};



================================================
File: lib/rules/advanced/plugin/limit-data-scope.js
================================================
module.exports = {
  rules: {
    'limit-data-scope': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Enforces several best practices for data scoping: disallows global object modification, suggests moving variables to their narrowest functional scope, and discourages `var` usage.',
          category: 'Best Practices',
          recommended: false,
        },
        schema: [],
        messages: {
          noModifyGlobal:
            'Avoid modifying the global object "{{objectName}}". "{{propertyName}}" should not be added globally.',
          moveToNarrowerScope:
            "Variable '{{variableName}}' is declared in {{declarationScopeType}} scope but appears to be used only within the '{{usageScopeIdentifier}}' {{usageScopeType}} scope. Consider moving its declaration into the '{{usageScopeIdentifier}}' scope.",
          useLetConst:
            "Prefer 'let' or 'const' over 'var' for variable '{{variableName}}'.",
        },
      },
      create(context) {
        const sourceCode = context.getSourceCode();
        const functionInfoForNarrowestScope = new Map();
        const globalObjects = new Set(['global', 'globalThis', 'window']);

        function getFunctionName(node) {
          if (node.id && node.id.name) {
            return node.id.name;
          }

          if (node.parent) {
            if (
              node.parent.type === 'VariableDeclarator' &&
              node.parent.id &&
              node.parent.id.name
            ) {
              return node.parent.id.name;
            }

            if (node.parent.type === 'Property' && node.parent.key) {
              return (
                node.parent.key.name ||
                node.parent.key.value ||
                '[anonymous_function]'
              );
            }

            if (
              node.parent.type === 'AssignmentExpression' &&
              node.parent.left &&
              node.parent.left.name
            ) {
              return node.parent.left.name;
            }
          }

          return '[anonymous_function]';
        }

        function getAllScopes(programScope) {
          const scopes = [];

          function collectScopes(scope) {
            scopes.push(scope);
            scope.childScopes.forEach(collectScopes);
          }

          collectScopes(programScope);
          return scopes;
        }

        function findContainingFunctionScope(startScope, targetScope) {
          let currentScope = startScope;

          while (currentScope && currentScope !== targetScope) {
            if (currentScope.type === 'function') {
              return currentScope;
            }
            currentScope = currentScope.upper;
          }

          return null;
        }

        return {
          ':function': function (node) {
            const name = getFunctionName(node);
            functionInfoForNarrowestScope.set(node, name);
          },

          AssignmentExpression(node) {
            const { left } = node;
            if (left.type !== 'MemberExpression') return;

            // Check if this is a direct assignment to a global object or nested assignment
            function findGlobalObjectInChain(memberExpr) {
              let current = memberExpr;

              while (current.type === 'MemberExpression') {
                if (
                  current.object.type === 'Identifier' &&
                  globalObjects.has(current.object.name)
                ) {
                  return {
                    objectNode: current.object,
                    rootMemberExpr: current,
                    topLevelProperty: current.property,
                  };
                }
                current = current.object;
              }

              return null;
            }

            const globalInfo = findGlobalObjectInChain(left);
            if (!globalInfo) return;

            const { objectNode, topLevelProperty } = globalInfo;
            const scope = sourceCode.getScope(objectNode);
            const reference = scope.references.find(
              ref => ref.identifier === objectNode
            );

            let isShadowed = false;
            if (
              reference &&
              reference.resolved &&
              reference.resolved.defs.length > 0
            ) {
              isShadowed = true;
            }

            if (!isShadowed) {
              let propertyName = '';
              if (globalInfo.rootMemberExpr.computed) {
                if (topLevelProperty.type === 'Literal') {
                  propertyName = String(topLevelProperty.value);
                } else if (topLevelProperty.type === 'Identifier') {
                  propertyName = topLevelProperty.name;
                } else {
                  propertyName = '[complex]';
                }
              } else if (topLevelProperty.type === 'Identifier') {
                propertyName = topLevelProperty.name;
              }

              context.report({
                node: left,
                messageId: 'noModifyGlobal',
                data: { objectName: objectNode.name, propertyName },
              });
            }
          },

          VariableDeclaration(node) {
            if (node.kind === 'var') {
              let firstVariableName = '[unnamed_variable]';
              if (
                node.declarations.length > 0 &&
                node.declarations[0].id &&
                node.declarations[0].id.name
              ) {
                firstVariableName = node.declarations[0].id.name;
              }

              context.report({
                node: node,
                messageId: 'useLetConst',
                data: { variableName: firstVariableName },
              });
            }
          },

          'Program:exit': function (programNode) {
            const programScope = sourceCode.getScope(programNode);
            const allScopes = getAllScopes(programScope);

            // Look for variables in module/global scopes
            const targetScopes = allScopes.filter(
              scope => scope.type === 'module' || scope.type === 'global'
            );

            targetScopes.forEach(scope => {
              scope.variables.forEach(variable => {
                // Skip if no definitions or references
                if (
                  variable.defs.length === 0 ||
                  variable.references.length === 0
                ) {
                  return;
                }

                // Skip built-in variables and imports
                if (
                  variable.defs.some(
                    def =>
                      def.type === 'ImportBinding' ||
                      def.type === 'ImplicitGlobalVariable' ||
                      (def.node && def.node.type === 'Program')
                  )
                ) {
                  return;
                }

                const declarationScope = variable.scope;
                const uniqueFunctionScopes = new Set();
                let allReferencesInsideFunctions = true;
                let hasNonWriteReferences = false;

                // Analyze all references to this variable
                for (const reference of variable.references) {
                  // Skip the initial declaration
                  if (reference.init) {
                    continue;
                  }

                  hasNonWriteReferences = true;
                  const referenceScope = sourceCode.getScope(
                    reference.identifier
                  );
                  const containingFunctionScope = findContainingFunctionScope(
                    referenceScope,
                    declarationScope
                  );

                  if (containingFunctionScope) {
                    uniqueFunctionScopes.add(containingFunctionScope);
                  } else {
                    // Reference is not inside a function (used at module/global level)
                    allReferencesInsideFunctions = false;
                    break;
                  }
                }

                // Only suggest moving if:
                // 1. All references are inside functions
                // 2. All references are inside the same single function
                // 3. There are actual non-write references
                // 4. The containing function is a direct child of the declaration scope
                if (
                  allReferencesInsideFunctions &&
                  uniqueFunctionScopes.size === 1 &&
                  hasNonWriteReferences
                ) {
                  const singleFunctionScope =
                    Array.from(uniqueFunctionScopes)[0];

                  // Check if the function scope is a direct child of the declaration scope
                  if (singleFunctionScope.upper === declarationScope) {
                    const variableNameNode = variable.defs[0].name;
                    const functionNode = singleFunctionScope.block;
                    const usageScopeIdentifier =
                      functionInfoForNarrowestScope.get(functionNode) ||
                      '[anonymous_function]';

                    context.report({
                      node: variableNameNode,
                      messageId: 'moveToNarrowerScope',
                      data: {
                        variableName: variable.name,
                        declarationScopeType: declarationScope.type,
                        usageScopeType: singleFunctionScope.type,
                        usageScopeIdentifier: usageScopeIdentifier,
                      },
                    });
                  }
                }
              });
            });
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/advanced/plugin/limit-reference-depth.js
================================================
/**
 * Converts a nested MemberExpression AST node into a human-readable dot/bracket path string.
 * Handles optional chaining, computed properties, and special cases like `this`, `super`, or call expressions.
 *
 * Example: Converts `foo.bar?.baz[qux]` into the string `foo.bar?.baz[qux]`.
 *
 * @param {ASTNode} node - The MemberExpression node to convert.
 * @param {SourceCode} sourceCode - The ESLint SourceCode object to extract text.
 * @returns {string} The constructed path string from the member expression.
 */

function getPropertyPathString(node, sourceCode) {
  if (!node) return '';
  const segments = [];

  let current = node;

  while (current && current.type === 'MemberExpression') {
    let prop;

    // If property is computed, e.g., obj[expr]
    if (current.computed) {
      prop = `${current.optional ? '?.' : ''}[${sourceCode.getText(current.property)}]`;
    } else {
      prop = `${current.optional ? '?.' : '.'}${current.property.name}`;
    }

    segments.unshift(prop);

    current = current.object;
    // Handle intermediate CallExpression like `obj().a`
    if (current && current.type === 'CallExpression') {
      const calleeText = sourceCode.getText(current.callee) + '()';
      segments.unshift(calleeText);
      break;
    }

    // Handle `this.a.b`
    if (current && current.type === 'ThisExpression') {
      segments.unshift('this');
      break;
    }

    // Handle base like `dotenv`, `myVar`, etc.
    if (current && current.type === 'Identifier') {
      segments.unshift(current.name);
      break;
    }
  }

  return segments.join('');
}

module.exports = {
  rules: {
    'limit-reference-depth': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Limits the depth of chained property access and requires optional chaining.',
          category: 'Best Practices',
          recommended: false,
        },
        schema: [
          {
            type: 'object',
            properties: {
              maxDepth: { type: 'integer', minimum: 1, default: 3 },
              requireOptionalChaining: { type: 'boolean', default: true },
              allowSinglePropertyAccess: { type: 'boolean', default: false },
              ignoredBases: {
                type: 'array',
                items: { type: 'string' },
                default: [],
              },
              ignoreCallExpressions: { type: 'boolean', default: true },
              ignoreImportedModules: { type: 'boolean', default: true },
              ignoreGlobals: { type: 'boolean', default: true },
              ignoreCommonPatterns: { type: 'boolean', default: true },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          tooDeep:
            "Property access chain '{{path}}' (depth {{chainDepth}}) exceeds the maximum allowed depth of {{maxDepthOption}}.",
          missingOptionalChaining:
            "Optional chaining (?.) should be used for accessing property '{{property}}' in '{{path}}'.",
        },
      },

      create: function (context) {
        const sourceCode = context.getSourceCode();
        const options = context.options[0] || {};

        // Load options or set defaults
        const maxDepthOption = options.maxDepth ?? 3;
        const requireOptionalChainingOpt =
          options.requireOptionalChaining ?? true;
        const allowSinglePropertyAccess =
          options.allowSinglePropertyAccess ?? false;
        const ignoreCallExpressions = options.ignoreCallExpressions ?? true;
        const ignoreImportedModules = options.ignoreImportedModules ?? true;
        const ignoreGlobals = options.ignoreGlobals ?? true;
        const ignoreCommonPatterns = options.ignoreCommonPatterns ?? true;

        // Track imported/required modules
        const importedModules = new Set();
        const requiredModules = new Set();

        // Track declared variables in current scope
        const declaredVariables = new Set();

        // Built-in global objects (minimal essential list)
        const globalObjects = new Set([
          'Math',
          'JSON',
          'Date',
          'Promise',
          'Object',
          'Array',
          'String',
          'Number',
          'Boolean',
          'console',
          'process',
          'window',
          'document',
          'global',
          'globalThis',
          'localStorage',
          'sessionStorage',
        ]);

        // User-defined ignored bases
        const userIgnoredBases = new Set(options.ignoredBases || []);

        // Common patterns that usually don't need optional chaining
        const commonSafePatterns = new Set([
          'this',
          'super',
          'module',
          'exports',
          '__dirname',
          '__filename',
        ]);

        // Utility to get base identifier from a chain
        function getBaseIdentifier(node) {
          let current = node;
          while (current && current.type === 'MemberExpression') {
            current = current.object;
          }
          if (current && current.type === 'CallExpression') {
            current = current.callee;
            while (current && current.type === 'MemberExpression') {
              current = current.object;
            }
          }
          return current && current.type === 'Identifier' ? current.name : null;
        }

        function shouldExemptChain(node) {
          const baseName = getBaseIdentifier(node);
          if (!baseName) return false;

          // User-defined exemptions
          if (userIgnoredBases.has(baseName)) return true;

          // Global objects
          if (ignoreGlobals && globalObjects.has(baseName)) return true;

          // Imported/required modules
          if (
            ignoreImportedModules &&
            (importedModules.has(baseName) || requiredModules.has(baseName))
          )
            return true;

          // Declared variables (function params, local vars, etc.)
          if (ignoreImportedModules && declaredVariables.has(baseName))
            return false;

          // Common safe patterns
          if (ignoreCommonPatterns && commonSafePatterns.has(baseName))
            return true;

          return false;
        }

        // Check if node is a CallExpression or ends with one
        function isOrEndsWithCallExpression(node) {
          if (node.type === 'CallExpression') return true;
          return (
            node.parent &&
            node.parent.type === 'CallExpression' &&
            node.parent.callee === node
          );
        }

        return {
          // Track imports and requires
          ImportDeclaration(node) {
            node.specifiers.forEach(spec => {
              if (
                spec.type === 'ImportDefaultSpecifier' ||
                spec.type === 'ImportNamespaceSpecifier'
              ) {
                importedModules.add(spec.local.name);
              } else if (spec.type === 'ImportSpecifier') {
                importedModules.add(spec.local.name);
              }
            });
          },

          VariableDeclarator(node) {
            // Track require() calls
            if (
              node.init &&
              node.init.type === 'CallExpression' &&
              node.init.callee.name === 'require' &&
              node.id.type === 'Identifier'
            ) {
              requiredModules.add(node.id.name);
            }

            // Track other variable declarations
            if (node.id.type === 'Identifier') {
              declaredVariables.add(node.id.name);
            }
          },

          FunctionDeclaration(node) {
            // Track function names
            if (node.id) {
              declaredVariables.add(node.id.name);
            }
            // Track parameters
            node.params.forEach(param => {
              if (param.type === 'Identifier') {
                declaredVariables.add(param.name);
              }
            });
          },

          ArrowFunctionExpression(node) {
            // Track arrow function parameters
            node.params.forEach(param => {
              if (param.type === 'Identifier') {
                declaredVariables.add(param.name);
              }
            });
          },

          FunctionExpression(node) {
            // Track function expression parameters
            node.params.forEach(param => {
              if (param.type === 'Identifier') {
                declaredVariables.add(param.name);
              }
            });
          },

          MemberExpression(node) {
            // Skip if this node is part of a larger chain (i.e., not the outermost one)
            if (
              node.parent.type === 'MemberExpression' &&
              node.parent.object === node
            ) {
              return;
            }

            // Skip if this is being called as a function and ignoreCallExpressions is true
            if (ignoreCallExpressions && isOrEndsWithCallExpression(node)) {
              return;
            }

            let chainDepth = 0;
            let current = node;
            const chainLinksReversed = [];

            // Traverse the chain backwards to compute depth
            while (current.type === 'MemberExpression') {
              chainDepth++;
              chainLinksReversed.push(current);
              if (current.object.type !== 'MemberExpression') {
                break;
              }
              current = current.object;
            }

            if (shouldExemptChain(current.object)) {
              return;
            }

            const fullPathString = getPropertyPathString(node, sourceCode);

            // 1. Check for depth violation
            if (chainDepth > maxDepthOption) {
              context.report({
                node: node,
                messageId: 'tooDeep',
                data: {
                  path: fullPathString,
                  chainDepth: chainDepth,
                  maxDepthOption: maxDepthOption,
                },
              });
              return;
            }

            // 2. Check for missing optional chaining
            if (requireOptionalChainingOpt && chainDepth > 0) {
              const links = chainLinksReversed.reverse();

              for (let i = 0; i < links.length; i++) {
                const linkNode = links[i];
                const objectOfThisLink = linkNode.object;

                if (!linkNode.optional) {
                  let shouldExemptThisLink = false;

                  if (allowSinglePropertyAccess) {
                    if (i === 0 && objectOfThisLink.type === 'Identifier') {
                      if (!shouldExemptChain(objectOfThisLink)) {
                        shouldExemptThisLink = true;
                      }
                    }
                  }

                  if (shouldExemptThisLink) {
                    continue;
                  }

                  // Report missing optional chaining
                  const problematicProperty = linkNode.computed
                    ? sourceCode.getText(linkNode.property)
                    : linkNode.property.name;

                  context.report({
                    node: linkNode,
                    messageId: 'missingOptionalChaining',
                    data: {
                      property: problematicProperty,
                      path: getPropertyPathString(linkNode, sourceCode),
                    },
                  });

                  break;
                }
              }
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/advanced/plugin/minimize-complexflows.js
================================================
module.exports = {
  rules: {
    'minimize-complexflows': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Enforces simplified control flow by limiting recursion and nesting depth, and detecting direct or lexically scoped recursion.',
          recommended: 'warn',
        },
        messages: {
          excessiveNesting:
            'Avoid nesting control structures deeper than {{maxDepth}} levels. Current depth: {{currentDepth}}.',
          unsafeRecursion:
            'Direct recursion detected in function `{{functionName}}`. Consider iteration or ensure a clear, bounded termination condition if recursion is intended and allowed.',
          lexicalRecursion:
            'Lexical recursion: function `{{calledFunctionName}}` is called from an inner scope of `{{currentFunctionName}}`, creating a recursive call pattern.',
        },
        schema: [
          {
            type: 'object',
            properties: {
              maxNestingDepth: {
                type: 'number',
                minimum: 1,
                default: 3,
              },
              allowRecursion: {
                type: 'boolean',
                default: false,
              },
            },
            additionalProperties: false,
          },
        ],
      },

      create(context) {
        const options = context.options[0] || {};
        const maxNestingDepth = options.maxNestingDepth ?? 3;
        const allowRecursion = options.allowRecursion ?? false;

        const nestingStack = [0]; // Initial global depth (not used for reporting)
        const functionNameStack = []; // Stores names of functions currently in the definition call stack

        function getFunctionNameForNode(node) {
          if (node.id && node.id.name) {
            return node.id.name;
          }
          if (
            (node.type === 'FunctionExpression' ||
              node.type === 'ArrowFunctionExpression') &&
            node.parent &&
            node.parent.type === 'VariableDeclarator' &&
            node.parent.id &&
            node.parent.id.type === 'Identifier'
          ) {
            return node.parent.id.name;
          }
          if (
            (node.type === 'FunctionExpression' ||
              node.type === 'ArrowFunctionExpression') &&
            node.parent &&
            node.parent.type === 'MethodDefinition' &&
            node.parent.key &&
            node.parent.key.type === 'Identifier'
          ) {
            return node.parent.key.name;
          }
          return null;
        }

        function checkNesting(node) {
          const currentFunctionNestingDepth =
            nestingStack[nestingStack.length - 1];
          if (currentFunctionNestingDepth > maxNestingDepth) {
            context.report({
              node: node,
              messageId: 'excessiveNesting',
              data: {
                maxDepth: maxNestingDepth,
                currentDepth: currentFunctionNestingDepth,
              },
            });
          }
        }

        // Common logic for when exiting any function node
        function handleFunctionExit() {
          // These variables (nestingStack, functionNameStack) are from the create() scope (closure)
          if (nestingStack.length > 1) {
            // Ensure we don't pop the global base
            nestingStack.pop();
          }
          if (functionNameStack.length > 0) {
            functionNameStack.pop();
          }
        }

        // --- AST Traversal ---
        return {
          // 1. Function Entry and Nesting Depth Management
          'FunctionDeclaration, FunctionExpression, ArrowFunctionExpression'(
            node
          ) {
            nestingStack.push(0); // Each function gets its own nesting counter

            const name = getFunctionNameForNode(node);
            functionNameStack.push(name || '<anonymous>'); // Push name or placeholder
          },

          // Function Exit (using the common handler)
          'FunctionDeclaration:exit': handleFunctionExit,
          'FunctionExpression:exit': handleFunctionExit,
          'ArrowFunctionExpression:exit': handleFunctionExit, // This was where the ReferenceError occurred

          // Control structures that increase nesting depth
          'IfStatement, ForStatement, ForInStatement, ForOfStatement, WhileStatement, DoWhileStatement, SwitchStatement'(
            node
          ) {
            if (nestingStack.length > 1) {
              // Ensure we are inside a function
              nestingStack[nestingStack.length - 1]++;
              checkNesting(node);
            }
          },

          // 2. Recursion Checks
          CallExpression(node) {
            if (allowRecursion || functionNameStack.length === 0) {
              return;
            }

            let calledFunctionName = null;
            if (node.callee.type === 'Identifier') {
              calledFunctionName = node.callee.name;
            } else if (
              node.callee.type === 'MemberExpression' &&
              node.callee.property.type === 'Identifier'
            ) {
              calledFunctionName = node.callee.property.name;
            }

            if (!calledFunctionName) {
              return;
            }

            const currentFunctionName =
              functionNameStack[functionNameStack.length - 1];

            // Direct recursion
            if (
              currentFunctionName &&
              currentFunctionName !== '<anonymous>' &&
              calledFunctionName === currentFunctionName
            ) {
              context.report({
                node: node,
                messageId: 'unsafeRecursion',
                data: { functionName: currentFunctionName },
              });
              return;
            }

            // Lexical recursion
            if (
              currentFunctionName &&
              functionNameStack.slice(0, -1).includes(calledFunctionName)
            ) {
              context.report({
                node: node,
                messageId: 'lexicalRecursion',
                data: {
                  calledFunctionName: calledFunctionName,
                  currentFunctionName: currentFunctionName,
                },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/advanced/plugin/minimize-deep-asynchronous-chains.js
================================================
module.exports = {
  rules: {
    'minimize-deep-asynchronous-chains': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Limits the depth of Promise chains and the number of await expressions in async functions.',
          category: 'Best Practices',
          recommended: false,
          url: 'https://your-doc-site.com/rules/minimize-deep-asynchronous-chains',
        },
        fixable: null,
        schema: [
          {
            type: 'object',
            properties: {
              maxPromiseChainLength: {
                type: 'integer',
                minimum: 1,
                default: 3,
              },
              maxAwaitExpressions: {
                type: 'integer',
                minimum: 1,
                default: 3,
              },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          tooManyThenCalls:
            'Promise chain starting at {{functionName}} has {{count}} .then/.catch/.finally calls, exceeding the maximum of {{maxCount}}.',
          tooManyAwaitExpressions:
            'Async function "{{functionName}}" has {{count}} await expressions, exceeding the maximum of {{maxCount}}.',
        },
      },
      create: function (context) {
        const options = context.options[0] || {};
        const maxPromiseChainLength =
          options.maxPromiseChainLength === undefined
            ? 3
            : options.maxPromiseChainLength;
        const maxAwaitExpressions =
          options.maxAwaitExpressions === undefined
            ? 3
            : options.maxAwaitExpressions;

        function getFunctionName(node) {
          if (node.id && node.id.name) return node.id.name;
          if (
            node.parent &&
            node.parent.type === 'VariableDeclarator' &&
            node.parent.id.name
          )
            return node.parent.id.name;
          if (
            node.parent &&
            node.parent.type === 'Property' &&
            node.parent.key.name
          )
            return node.parent.key.name;
          if (
            node.parent &&
            node.parent.type === 'AssignmentExpression' &&
            node.parent.left.name
          )
            return node.parent.left.name;
          return 'anonymous function';
        }

        // Track processed chains to avoid duplicate reports
        const processedChains = new Set();

        function getChainIdentifier(node) {
          // Create a unique identifier for the chain based on location
          return `${node.loc.start.line}:${node.loc.start.column}-${node.loc.end.line}:${node.loc.end.column}`;
        }

        function getPromiseOriginName(node) {
          // Navigate to the root of the promise chain
          let current = node;

          // Go up the chain to find the original promise
          while (
            current.callee &&
            current.callee.type === 'MemberExpression' &&
            ['then', 'catch', 'finally'].includes(current.callee.property.name)
          ) {
            if (current.callee.object.type === 'CallExpression') {
              // Check if this is still part of the chain
              if (
                current.callee.object.callee.type === 'MemberExpression' &&
                ['then', 'catch', 'finally'].includes(
                  current.callee.object.callee.property.name
                )
              ) {
                current = current.callee.object;
              } else {
                // This is the original function call that returns a promise
                break;
              }
            } else {
              // Reached the base promise
              break;
            }
          }

          // Extract the name from the original promise
          const originalPromise = current.callee.object;

          if (originalPromise.type === 'Identifier') {
            return originalPromise.name;
          } else if (originalPromise.type === 'CallExpression') {
            if (originalPromise.callee.type === 'Identifier') {
              return originalPromise.callee.name + '()';
            } else if (
              originalPromise.callee.type === 'MemberExpression' &&
              originalPromise.callee.property.name
            ) {
              return originalPromise.callee.property.name + '()';
            }
          } else if (originalPromise.type === 'NewExpression') {
            if (originalPromise.callee.type === 'Identifier') {
              return 'new ' + originalPromise.callee.name + '()';
            }
          }

          return 'a Promise';
        }

        function analyzePromiseChain(startNode) {
          let current = startNode;
          let chainLength = 0;
          const chainNodes = [];

          // Count the chain length starting from this node
          while (
            current &&
            current.type === 'CallExpression' &&
            current.callee.type === 'MemberExpression' &&
            ['then', 'catch', 'finally'].includes(current.callee.property.name)
          ) {
            chainLength++;
            chainNodes.push(current);
            current = current.callee.object;
          }

          return { chainLength, chainNodes, rootPromise: current };
        }

        // Simplified approach: Count chain length from each .then/.catch/.finally
        function checkPromiseChain(node) {
          const chainId = getChainIdentifier(node);
          if (processedChains.has(chainId)) {
            return; // Already processed this exact node
          }

          const { chainLength } = analyzePromiseChain(node);

          if (chainLength > maxPromiseChainLength) {
            processedChains.add(chainId);

            const originName = getPromiseOriginName(node);

            context.report({
              node: node,
              messageId: 'tooManyThenCalls',
              data: {
                functionName: originName,
                count: chainLength,
                maxCount: maxPromiseChainLength,
              },
            });
          }
        }

        // --- Async/Await Logic ---
        const functionAwaitCounts = new Map();

        function enterAsyncFunction(node) {
          functionAwaitCounts.set(node, 0);
        }

        function exitAsyncFunction(node) {
          const awaitCount = functionAwaitCounts.get(node) || 0;

          if (awaitCount > maxAwaitExpressions) {
            context.report({
              node: node,
              messageId: 'tooManyAwaitExpressions',
              data: {
                functionName: getFunctionName(node),
                count: awaitCount,
                maxCount: maxAwaitExpressions,
              },
            });
          }

          functionAwaitCounts.delete(node);
        }

        function findContainingAsyncFunction(node) {
          let parent = node.parent;
          while (parent) {
            if (
              (parent.type === 'FunctionDeclaration' ||
                parent.type === 'FunctionExpression' ||
                parent.type === 'ArrowFunctionExpression') &&
              parent.async
            ) {
              return parent;
            }
            parent = parent.parent;
          }
          return null;
        }

        return {
          // For Promise chains - target the outermost .then/.catch/.finally calls
          'CallExpression[callee.type="MemberExpression"][callee.property.name=/^(then|catch|finally)$/]':
            function (node) {
              checkPromiseChain(node);
            },

          // For async/await
          'FunctionDeclaration[async=true]': enterAsyncFunction,
          'FunctionDeclaration[async=true]:exit': exitAsyncFunction,
          'ArrowFunctionExpression[async=true]': enterAsyncFunction,
          'ArrowFunctionExpression[async=true]:exit': exitAsyncFunction,
          'FunctionExpression[async=true]': enterAsyncFunction,
          'FunctionExpression[async=true]:exit': exitAsyncFunction,

          AwaitExpression(node) {
            const containingFunction = findContainingAsyncFunction(node);
            if (
              containingFunction &&
              functionAwaitCounts.has(containingFunction)
            ) {
              const currentCount = functionAwaitCounts.get(containingFunction);
              functionAwaitCounts.set(containingFunction, currentCount + 1);
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/advanced/plugin/use-runtime-assertions.js
================================================
module.exports = {
  rules: {
    'use-runtime-assertions': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforce the presence of a minimum number of runtime assertions in functions to validate inputs and critical intermediate values.',
          category: 'Best Practices',
          recommended: false,
        },
        fixable: null,
        schema: [
          {
            type: 'object',
            properties: {
              minAssertions: {
                type: 'integer',
                minimum: 0,
                default: 2,
              },
              assertionUtilityNames: {
                type: 'array',
                items: {
                  type: 'string',
                },
                default: ['assert'],
              },
              ignoreEmptyFunctions: {
                type: 'boolean',
                default: true,
              },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          missingAssertions:
            'Function "{{functionName}}" should have at least {{minCount}} runtime assertions, but found {{foundCount}}.',
        },
      },
      create: function (context) {
        const options = context.options[0] || {};
        const minAssertions =
          options.minAssertions === undefined ? 2 : options.minAssertions;
        const assertionUtilityNames = new Set(
          options.assertionUtilityNames || ['assert']
        );
        const ignoreEmptyFunctions =
          options.ignoreEmptyFunctions === undefined
            ? true
            : options.ignoreEmptyFunctions;

        function getFunctionName(node) {
          if (node.id && node.id.name) {
            return node.id.name;
          }
          if (
            node.parent &&
            node.parent.type === 'VariableDeclarator' &&
            node.parent.id &&
            node.parent.id.name
          ) {
            return node.parent.id.name;
          }
          if (
            node.parent &&
            node.parent.type === 'Property' &&
            node.parent.key &&
            node.parent.key.name
          ) {
            return node.parent.key.name;
          }
          if (
            node.parent &&
            node.parent.type === 'AssignmentExpression' &&
            node.parent.left &&
            node.parent.left.type === 'Identifier' && // Ensure left is an Identifier
            node.parent.left.name
          ) {
            return node.parent.left.name;
          }
          return 'anonymous';
        }

        function isEmpty(functionBodyStatements) {
          return !functionBodyStatements || functionBodyStatements.length === 0;
        }

        function checkFunction(node) {
          // Skip if no body (for function declarations with no body, rare in JS, or arrow functions with implicit return)
          if (!node.body) {
            return;
          }

          // Arrow functions with expression body (e.g. `() => x`) don't have a BlockStatement body
          if (node.body.type !== 'BlockStatement') {
            // If minAssertions is 0, these are fine. Otherwise, they have 0 assertions.
            if (minAssertions > 0) {
              context.report({
                node: node,
                messageId: 'missingAssertions',
                data: {
                  functionName: getFunctionName(node),
                  minCount: minAssertions,
                  foundCount: 0,
                },
              });
            }
            return;
          }

          const functionBodyStatements = node.body.body;

          if (ignoreEmptyFunctions && isEmpty(functionBodyStatements)) {
            // If minAssertions is 0 and ignoreEmptyFunctions is true, it's still fine.
            // If ignoreEmptyFunctions is false, the check proceeds below.
            // If minAssertions > 0 and ignoreEmptyFunctions is true, this is fine.
            if (minAssertions > 0) {
              return;
            }
            // If minAssertions is 0, and ignoreEmptyFunctions is true, we can return.
            // If ignoreEmptyFunctions is false, we let it proceed to count (which will be 0)
            // and then it will correctly report if minAssertions is > 0 (covered by the final check).
            // This ensures that { ignoreEmptyFunctions: false, minAssertions: 0 } is valid.
            if (minAssertions === 0) {
              return;
            }
          }

          let assertionCount = 0;

          function findAssertionsRecursive(currentNode) {
            if (!currentNode) {
              return;
            }

            // Check if the current node itself is an assertion primitive
            if (currentNode.type === 'ThrowStatement') {
              assertionCount++;
            } else if (
              currentNode.type === 'ExpressionStatement' &&
              currentNode.expression.type === 'CallExpression'
            ) {
              const callee = currentNode.expression.callee;
              if (
                callee.type === 'MemberExpression' &&
                callee.object.type === 'Identifier' &&
                callee.object.name === 'console' &&
                callee.property.type === 'Identifier' &&
                callee.property.name === 'assert' &&
                assertionUtilityNames.has('assert')
              ) {
                assertionCount++;
              } else if (
                callee.type === 'Identifier' &&
                assertionUtilityNames.has(callee.name)
              ) {
                assertionCount++;
              }
            }

            switch (currentNode.type) {
              case 'BlockStatement':
                currentNode.body.forEach(findAssertionsRecursive);
                break;
              case 'IfStatement':
                findAssertionsRecursive(currentNode.consequent);
                if (currentNode.alternate) {
                  findAssertionsRecursive(currentNode.alternate);
                }
                break;
              case 'ForStatement':
                if (currentNode.init) findAssertionsRecursive(currentNode.init);
                findAssertionsRecursive(currentNode.body);
                break;
              case 'ForInStatement':
              case 'ForOfStatement':
                // left and right are expressions or declarations
                findAssertionsRecursive(currentNode.body);
                break;
              case 'WhileStatement':
              case 'DoWhileStatement':
                // test is an expression
                findAssertionsRecursive(currentNode.body);
                break;
              case 'SwitchStatement':
                // discriminant is an expression
                currentNode.cases.forEach(switchCase => {
                  // switchCase.test is an expression
                  switchCase.consequent.forEach(findAssertionsRecursive);
                });
                break;
              case 'TryStatement':
                findAssertionsRecursive(currentNode.block);
                if (currentNode.handler) {
                  // CatchClause
                  findAssertionsRecursive(currentNode.handler.body);
                }
                if (currentNode.finalizer) {
                  findAssertionsRecursive(currentNode.finalizer);
                }
                break;
              case 'LabeledStatement':
              case 'WithStatement':
                findAssertionsRecursive(currentNode.body);
                break;
            }
          }

          // For functions with BlockStatement bodies (already checked earlier)
          // Start traversal from the function's BlockStatement node (node.body)
          findAssertionsRecursive(node.body);

          if (assertionCount < minAssertions) {
            context.report({
              node: node,
              messageId: 'missingAssertions',
              data: {
                functionName: getFunctionName(node),
                minCount: minAssertions,
                foundCount: assertionCount,
              },
            });
          }
        }

        return {
          FunctionDeclaration: checkFunction,
          FunctionExpression: checkFunction,
          ArrowFunctionExpression: checkFunction,
        };
      },
    },
  },
};



================================================
File: lib/rules/angular/index.js
================================================
const angularNoForbiddenServices = require('./plugin/angular-no-forbidden-services');
const angularNoUnusedInputs = require('./plugin/angular-no-unused-inputs');
const angularNoDirectDomManipulation = require('./plugin/angular-no-direct-dom-manipulation');
const angularLimitInput = require('./plugin/angular-limit-input');
const angularFilenaming = require('./plugin/angular-filenaming');

module.exports = {
  rules: {
    ...angularNoForbiddenServices.rules,
    ...angularNoUnusedInputs.rules,
    ...angularNoDirectDomManipulation.rules,
    ...angularLimitInput.rules,
    ...angularFilenaming.rules,
  },
};



================================================
File: lib/rules/angular/plugin/angular-filenaming.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'angular-filenaming': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Enforces user-defined naming conventions for Angular files (PascalCase, kebab-case, camelCase)',
        },
        messages: {
          invalidFileName:
            'File "{{name}}" does not follow the {{expected}} naming convention.',
        },
        schema: [
          {
            type: 'object',
            properties: {
              component: {
                enum: ['kebab-case', 'camelCase', 'PascalCase'],
                default: 'kebab-case',
              },
              service: {
                enum: ['kebab-case', 'camelCase', 'PascalCase'],
                default: 'camelCase',
              },
              module: {
                enum: ['kebab-case', 'camelCase', 'PascalCase'],
                default: 'PascalCase',
              },
            },
            additionalProperties: false,
          },
        ],
      },
      create(context) {
        const options = context.options[0] || {};
        const componentConvention = options.component || 'kebab-case';
        const serviceConvention = options.service || 'camelCase';
        const moduleConvention = options.module || 'PascalCase';

        const namingPatterns = {
          'kebab-case': /^[a-z0-9]+(-[a-z0-9]+)*$/,
          PascalCase: /^[A-Z][a-zA-Z0-9]*$/,
          camelCase: /^[a-z][a-zA-Z0-9]*$/,
        };

        const componentPattern = /\.component\.ts$/;
        const servicePattern = /\.service\.ts$/;
        const modulePattern = /\.module\.ts$/;

        function checkFileName(fileName, pattern, convention) {
          const baseName = fileName.replace(pattern, '');
          return namingPatterns[convention].test(baseName);
        }

        return {
          Program(node) {
            const filePath = context.getFilename();
            const fileName = path.basename(filePath);
            let expectedConvention;

            if (componentPattern.test(fileName)) {
              expectedConvention = componentConvention;
              if (
                !checkFileName(fileName, componentPattern, componentConvention)
              ) {
                context.report({
                  node,
                  messageId: 'invalidFileName',
                  data: { name: fileName, expected: expectedConvention },
                });
              }
            } else if (servicePattern.test(fileName)) {
              expectedConvention = serviceConvention;
              if (!checkFileName(fileName, servicePattern, serviceConvention)) {
                context.report({
                  node,
                  messageId: 'invalidFileName',
                  data: { name: fileName, expected: expectedConvention },
                });
              }
            } else if (modulePattern.test(fileName)) {
              expectedConvention = moduleConvention;
              if (!checkFileName(fileName, modulePattern, moduleConvention)) {
                context.report({
                  node,
                  messageId: 'invalidFileName',
                  data: { name: fileName, expected: expectedConvention },
                });
              }
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/angular/plugin/angular-limit-input.js
================================================
module.exports = {
  rules: {
    'angular-limit-input': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Limit the number of @Input() and @Output() properties in a component to a configurable number',
        },
        messages: {
          tooManyInputsOutputs:
            'Component "{{name}}" has too many @Input() or @Output() properties ({{count}}), limit is {{max}}.',
        },
        schema: [
          {
            type: 'object',
            properties: {
              max: {
                type: 'integer',
                minimum: 1,
                default: 5,
              },
            },
            additionalProperties: false,
          },
        ],
      },
      create(context) {
        const { max = 5 } = context.options[0] || {};
        let inputOutputCount = 0;

        return {
          ClassDeclaration(node) {
            const className = node.id.name;
            inputOutputCount = 0;

            node.body.body.forEach(member => {
              if (member.decorators) {
                member.decorators.forEach(decorator => {
                  const decoratorName =
                    decorator.expression.callee.name ||
                    decorator.expression.callee.property.name;
                  if (decoratorName === 'Input' || decoratorName === 'Output') {
                    inputOutputCount += 1;
                  }
                });
              }
            });

            if (inputOutputCount > max) {
              context.report({
                node,
                messageId: 'tooManyInputsOutputs',
                data: { name: className, count: inputOutputCount, max },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/angular/plugin/angular-no-direct-dom-manipulation.js
================================================
module.exports = {
  rules: {
    'angular-no-direct-dom-manipulation': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Disallow direct DOM manipulation and enforce usage of Renderer2 for DOM manipulations in Angular',
        },
        messages: {
          avoidDirectDom:
            'Avoid direct DOM manipulation with "{{method}}". Use Angular\'s Renderer2 for DOM interactions.',
        },
        schema: [],
      },
      create(context) {
        const forbiddenMethods = [
          'getElementById',
          'querySelector',
          'querySelectorAll',
        ];
        const forbiddenObjects = ['document'];

        return {
          MemberExpression(node) {
            const { object, property } = node;

            // Check for forbidden document methods like document.getElementById()
            if (
              forbiddenObjects.includes(object.name) &&
              forbiddenMethods.includes(property.name)
            ) {
              context.report({
                node,
                messageId: 'avoidDirectDom',
                data: {
                  method: `${object.name}.${property.name}`,
                },
              });
            }

            // Check for ElementRef.nativeElement access pattern
            if (
              object.type === 'MemberExpression' &&
              object.property.name === 'nativeElement'
            ) {
              const identifier = object.object; // This will be 'elRef' or whatever the injected instance name is

              // Make sure the identifier is valid and being used with nativeElement
              if (identifier.type === 'Identifier') {
                context.report({
                  node,
                  messageId: 'avoidDirectDom',
                  data: {
                    method: `${identifier.name}.nativeElement`,
                  },
                });
              }
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/angular/plugin/angular-no-forbidden-services.js
================================================
const ts = require('@typescript-eslint/typescript-estree');

module.exports = {
  rules: {
    'angular-no-forbidden-services': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Disallow injection of certain services directly into components',
          category: 'Best Practices',
          recommended: true,
        },
        messages: {
          forbiddenService:
            "The service '{{ service }}' should not be injected directly into components. Consider moving it to a dedicated service or resolver.",
        },
        schema: [
          {
            type: 'object',
            properties: {
              forbiddenServices: {
                type: 'array',
                items: { type: 'string' },
              },
            },
            additionalProperties: false,
          },
        ],
      },
      create(context) {
        const options = context.options[0] || {};
        const forbiddenServices = new Set(
          options.forbiddenServices || ['HttpClient']
        );

        function isComponent(node) {
          return (
            node.decorators &&
            node.decorators.some(
              decorator =>
                decorator.expression.type === 'CallExpression' &&
                decorator.expression.callee.name === 'Component'
            )
          );
        }

        function checkConstructorParameters(params) {
          params.forEach(param => {
            if (
              param.type === 'TSParameterProperty' &&
              param.parameter.type === 'Identifier'
            ) {
              const serviceType =
                param.parameter.typeAnnotation?.typeAnnotation?.typeName?.name;
              if (serviceType && forbiddenServices.has(serviceType)) {
                context.report({
                  node: param,
                  messageId: 'forbiddenService',
                  data: { service: serviceType },
                });
              }
            }
          });
        }

        return {
          Program(node) {
            const ast = ts.parse(context.getSourceCode().text, {
              jsx: true,
              range: true,
              loc: true,
            });

            ts.simpleTraverse(ast, {
              enter: node => {
                if (node.type === 'ClassDeclaration' && isComponent(node)) {
                  const constructor = node.body.body.find(
                    member =>
                      member.type === 'MethodDefinition' &&
                      member.kind === 'constructor'
                  );
                  if (constructor) {
                    checkConstructorParameters(constructor.value.params);
                  }
                }
              },
            });
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/angular/plugin/angular-no-unused-inputs.js
================================================
const ts = require('@typescript-eslint/typescript-estree');

module.exports = {
  rules: {
    'angular-no-unused-inputs': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Warn if an @Input() property is declared but never used within the component',
        },
        messages: {
          unusedInput:
            'The @Input() property "{{property}}" is declared but never used in the component.',
        },
        schema: [], // No options for now
      },
      create(context) {
        const inputProperties = new Set();
        const usedProperties = new Set();

        function isInputDecorator(decorator) {
          return (
            decorator.expression &&
            decorator.expression.type === 'CallExpression' &&
            decorator.expression.callee &&
            decorator.expression.callee.type === 'Identifier' &&
            decorator.expression.callee.name === 'Input'
          );
        }

        return {
          Program(node) {
            // Parse the entire source code using TypeScript parser
            const ast = ts.parse(context.getSourceCode().text, {
              jsx: true,
              range: true,
              loc: true,
            });

            // Traverse the AST to find Input decorators and property usages
            ts.simpleTraverse(ast, {
              enter: node => {
                if (node.type === 'PropertyDefinition' && node.decorators) {
                  if (node.decorators.some(isInputDecorator)) {
                    inputProperties.add(node.key.name);
                  }
                } else if (
                  node.type === 'MemberExpression' &&
                  node.object.type === 'ThisExpression' &&
                  node.property.type === 'Identifier'
                ) {
                  usedProperties.add(node.property.name);
                }
              },
            });

            // Report unused inputs
            inputProperties.forEach(inputProp => {
              if (!usedProperties.has(inputProp)) {
                context.report({
                  node: ast,
                  messageId: 'unusedInput',
                  data: {
                    property: inputProp,
                  },
                });
              }
            });
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/index.js
================================================
const fileKebabcase = require('./plugin/file-kebabcase');
const maxLinesPerFile = require('./plugin/max-lines-per-file');
const maxLinesPerFunction = require('./plugin/max-lines-per-function');
const consistentReturn = require('./plugin/consistent-return');
const maxFunctionParams = require('./plugin/max-function-params');
const noSingleCharacterVars = require('./plugin/no-single-character-vars');
const varsLowercase = require('./plugin/vars-lowercase');
const folderLowercase = require('./plugin/folder-lowercase');
const fileLowercase = require('./plugin/file-lowercase');
const folderPascalcase = require('./plugin/folder-pascalcase');
const folderKebabcase = require('./plugin/folder-kebabcase');
const folderCamelcase = require('./plugin/folder-camelcase');
const fileCamelcase = require('./plugin/file-camelcase');
const functionPascalcase = require('./plugin/function-pascalcase');
const filePascalcase = require('./plugin/file-pascalcase');
const varsSnakecase = require('./plugin/vars-snakecase');
const varsPascalcase = require('./plugin/vars-pascalcase');
const classPascal = require('./plugin/class-pascalcase');
const functionCamelcase = require('./plugin/function-camelcase');
const functionDescriptive = require('./plugin/function-descriptive');
const varsCamelcase = require('./plugin/vars-camelcase');
const descriptiveVars = require('./plugin/vars-descriptive');

module.exports = {
  rules: {
    ...fileKebabcase.rules,
    ...classPascal.rules,
    ...functionCamelcase.rules,
    ...functionDescriptive.rules,
    ...varsCamelcase.rules,
    ...descriptiveVars.rules,
    ...varsPascalcase.rules,
    ...varsSnakecase.rules,
    ...filePascalcase.rules,
    ...functionPascalcase.rules,
    ...fileCamelcase.rules,
    ...folderCamelcase.rules,
    ...folderKebabcase.rules,
    ...folderPascalcase.rules,
    ...fileLowercase.rules,
    ...folderLowercase.rules,
    ...varsLowercase.rules,
    ...noSingleCharacterVars.rules,
    ...maxFunctionParams.rules,
    ...consistentReturn.rules,
    ...maxLinesPerFunction.rules,
    ...maxLinesPerFile.rules,
  },
};



================================================
File: lib/rules/general/plugin/class-pascalcase.js
================================================
module.exports = {
  rules: {
    'class-pascalcase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce PascalCase for class names',
          category: 'Stylistic Issues',
          recommended: false,
        },
        schema: [], // Add schema if your rule has options
      },
      create: function (context) {
        return {
          ClassDeclaration(node) {
            // Check if the class name is not in PascalCase
            if (!/^[A-Z][A-Za-z]*$/.test(node.id.name)) {
              context.report({
                node: node.id,
                message: 'Class name "{{name}}" must be in PascalCase.',
                data: {
                  name: node.id.name,
                },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/consistent-return.js
================================================
module.exports = {
  rules: {
    'consistent-return': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Require return statements to either always or never specify values',
          category: 'Best Practices',
          recommended: false,
        },
        schema: [],
        messages: {
          missingReturn: 'Expected {{name}} to return a value.',
          inconsistentReturn:
            'Function {{name}} should either always return a value or never return a value.',
        },
      },
      create(context) {
        function checkFunction(node) {
          let hasReturnWithValue = false;
          let hasReturnWithoutValue = false;
          let hasAnyReturn = false;
          let isConsistent = true;

          function checkReturnStatement(returnNode, inConditional) {
            hasAnyReturn = true;
            if (returnNode.argument) {
              hasReturnWithValue = true;
            } else {
              hasReturnWithoutValue = true;
            }
            if (!inConditional && hasReturnWithValue && hasReturnWithoutValue) {
              isConsistent = false;
            }
          }

          function checkBody(body, inConditional = false) {
            if (body.type === 'BlockStatement') {
              body.body.forEach(statement => {
                if (statement.type === 'ReturnStatement') {
                  checkReturnStatement(statement, inConditional);
                } else if (statement.type === 'IfStatement') {
                  checkBody(statement.consequent, true);
                  if (statement.alternate) {
                    checkBody(statement.alternate, true);
                  }
                }
              });
            } else if (body.type === 'ReturnStatement') {
              checkReturnStatement(body, inConditional);
            }
          }

          checkBody(node.body);

          if (!hasAnyReturn) {
            context.report({
              node,
              messageId: 'missingReturn',
              data: {
                name: node.id ? node.id.name : 'function',
              },
            });
          } else if (!isConsistent) {
            context.report({
              node,
              messageId: 'inconsistentReturn',
              data: {
                name: node.id ? node.id.name : 'function',
              },
            });
          }
        }

        return {
          FunctionDeclaration: checkFunction,
          FunctionExpression: checkFunction,
          ArrowFunctionExpression(node) {
            if (node.body.type !== 'BlockStatement') {
              // Implicit return, always consistent
              return;
            }
            checkFunction(node);
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/file-camelcase.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'file-camelcase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce camelCase naming convention for filenames',
        },
        messages: {
          invalidFileName:
            'Filename "{{name}}" should be in camelCase and follow the camelCase pattern.',
        },
      },
      create(context) {
        return {
          Program(node) {
            const filePath = context.getFilename();
            const fileName = path.basename(filePath);

            // Regex for camelCase
            const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;
            const allowedExtensions = /\.(js|ts|json|config\.mjs|config\.js)$/;

            const baseFileName = fileName.replace(allowedExtensions, '');

            // Validate the file name
            if (!camelCaseRegex.test(baseFileName)) {
              context.report({
                node,
                messageId: 'invalidFileName',
                data: { name: fileName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/file-kebabcase.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'file-kebabcase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce lowercase and kebab-case naming for filenames',
        },
        messages: {
          invalidFileName:
            'Filename "{{name}}" should be lowercase and follow kebab-case if it has more than 10 characters.',
        },
      },
      create(context) {
        return {
          Program(node) {
            const filePath = context.getFilename();
            const fileName = path.basename(filePath);

            // Regex for lowercase and kebab-case
            const lowerCaseRegex = /^[a-z0-9]+(-[a-z0-9]+)*$/;
            const allowedExtensions = /\.(js|ts|json|config\.mjs|config\.js)$/;

            const baseFileName = fileName.replace(allowedExtensions, '');

            // Validate the file name
            const isFileNameInvalid =
              (baseFileName.length > 10 &&
                !lowerCaseRegex.test(baseFileName)) ||
              (baseFileName.length <= 10 &&
                baseFileName !== baseFileName.toLowerCase());

            if (isFileNameInvalid) {
              context.report({
                node,
                messageId: 'invalidFileName',
                data: { name: fileName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/file-lowercase.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'file-lowercase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce lowercase naming convention for filenames',
        },
        messages: {
          invalidFileName: 'Filename "{{name}}" should be in lowercase.',
        },
      },
      create(context) {
        return {
          Program(node) {
            const filePath = context.getFilename();
            const fileName = path.basename(filePath);
            const allowedExtensions = /\.(js|ts|json|config\.mjs|config\.js)$/;

            const baseFileName = fileName.replace(allowedExtensions, '');

            // Regex for lowercase and allowed file name characters
            const lowerCaseRegex = /^[a-z0-9]+(-[a-z0-9]+)*$/;

            // Check if filename does not match the lowercase regex
            if (!lowerCaseRegex.test(baseFileName)) {
              context.report({
                node,
                messageId: 'invalidFileName',
                data: { name: fileName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/file-pascalcase.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'file-pascalcase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce PascalCase naming convention for filenames',
        },
        messages: {
          invalidFileName: 'Filename "{{name}}" should be in PascalCase.',
        },
      },
      create(context) {
        return {
          Program(node) {
            const filePath = context.getFilename();
            const fileName = path.basename(filePath);

            // Regex for PascalCase
            const pascalCaseRegex = /^[A-Z][a-zA-Z0-9]*$/;
            const allowedExtensions = /\.(js|ts|json|config\.mjs|config\.js)$/;

            const baseFileName = fileName.replace(allowedExtensions, '');

            // Validate the file name
            const isFileNameInvalid = !pascalCaseRegex.test(baseFileName);

            if (isFileNameInvalid) {
              context.report({
                node,
                messageId: 'invalidFileName',
                data: { name: fileName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/folder-camelcase.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'folder-camelcase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce camelCase naming convention for folder names',
        },
        messages: {
          invalidFolderName:
            'Folder "{{name}}" should be in camelCase and follow the camelCase pattern.',
        },
      },
      create(context) {
        return {
          Program(node) {
            const filePath = context.getFilename();
            const dirName = path.basename(path.dirname(filePath));

            // Regex for camelCase
            const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;

            // Validate the directory name
            if (!camelCaseRegex.test(dirName)) {
              context.report({
                node,
                messageId: 'invalidFolderName',
                data: { name: dirName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/folder-kebabcase.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'folder-kebabcase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce lowercase and kebab-case naming for folders',
        },
        messages: {
          invalidFolderName:
            'Folder "{{name}}" should be lowercase and follow kebab-case if it has more than 10 characters.',
        },
      },
      create(context) {
        return {
          Program(node) {
            const filePath = context.getFilename();
            const dirName = path.basename(path.dirname(filePath));

            // Regex for lowercase and kebab-case
            const lowerCaseRegex = /^[a-z0-9]+(-[a-z0-9]+)*$/;

            // Validate the directory name
            const isDirNameInvalid =
              (dirName.length > 10 && !lowerCaseRegex.test(dirName)) ||
              (dirName.length <= 10 && dirName !== dirName.toLowerCase());

            if (isDirNameInvalid) {
              context.report({
                node,
                messageId: 'invalidFolderName',
                data: { name: dirName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/folder-lowercase.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'folder-lowercase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce lowercase naming convention for folder names',
        },
        messages: {
          invalidFolderName: 'Folder "{{name}}" should be in lowercase.',
        },
      },
      create(context) {
        return {
          Program(node) {
            const filePath = context.getFilename();
            const dirName = path.basename(path.dirname(filePath));

            // Regex for lowercase only
            const lowerCaseRegex = /^[a-z0-9]+(-[a-z0-9]+)*$/;

            // Check if folder name is not lowercase
            if (!lowerCaseRegex.test(dirName)) {
              context.report({
                node,
                messageId: 'invalidFolderName',
                data: { name: dirName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/folder-pascalcase.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'folder-pascalcase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce PascalCase naming convention for folder names',
        },
        messages: {
          invalidFolderName: 'Folder "{{name}}" should be in PascalCase.',
        },
      },
      create(context) {
        return {
          Program(node) {
            const filePath = context.getFilename();
            const dirName = path.basename(path.dirname(filePath));

            // Regex for PascalCase
            const pascalCaseRegex = /^[A-Z][a-zA-Z0-9]*$/;

            // Validate the directory name
            const isDirNameInvalid = !pascalCaseRegex.test(dirName);

            if (isDirNameInvalid) {
              context.report({
                node,
                messageId: 'invalidFolderName',
                data: { name: dirName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/function-camelcase.js
================================================
const camelCase = /^[a-z][a-zA-Z0-9]*$/;

module.exports = {
  rules: {
    'function-camelcase': {
      meta: {
        type: 'problem',
        docs: {
          description: 'Enforce camelCase naming convention for function names',
        },
        schema: [], // No options needed
        messages: {
          notCamelCase: "Function name '{{name}}' should be in camelCase.",
        },
      },
      create(context) {
        function checkFunctionName(node) {
          const functionName = node.id && node.id.name;

          // Ensure functionName is a string before proceeding
          if (typeof functionName !== 'string') {
            return;
          }

          // Check if function name is in camelCase
          if (!camelCase.test(functionName)) {
            context.report({
              node: node.id,
              messageId: 'notCamelCase',
              data: { name: functionName },
            });
          }
        }

        return {
          FunctionDeclaration(node) {
            checkFunctionName(node);
          },
          FunctionExpression(node) {
            if (
              node.parent &&
              node.parent.type === 'VariableDeclarator' &&
              node.parent.id
            ) {
              checkFunctionName(node.parent);
            }
          },
          ArrowFunctionExpression(node) {
            if (
              node.parent &&
              node.parent.type === 'VariableDeclarator' &&
              node.parent.id
            ) {
              checkFunctionName(node.parent);
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/function-descriptive.js
================================================
const { isVerb } = require('../../../utils/check-verb');

module.exports = {
  rules: {
    'function-descriptive': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Enforce function names to start with a verb and be descriptive',
        },
        schema: [], // No options needed
        messages: {
          notDescriptive:
            "Function name '{{name}}' should start with a verb and be descriptive.",
        },
      },
      create(context) {
        return {
          FunctionDeclaration(node) {
            const functionName = node.id && node.id.name;

            // Ensure functionName is a string before proceeding
            if (typeof functionName !== 'string') {
              return;
            }

            // Extract the first word from camelCase function name
            const firstWord = functionName.split(/(?=[A-Z])/)[0].toLowerCase();

            // Check if the first word is a verb
            if (!isVerb(firstWord)) {
              context.report({
                node: node.id,
                messageId: 'notDescriptive',
                data: { name: functionName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/function-pascalcase.js
================================================
const pascalCase = /^[A-Z][a-zA-Z0-9]*$/;

module.exports = {
  rules: {
    'function-pascalcase': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforce PascalCase naming convention for function names',
        },
        schema: [], // No options needed
        messages: {
          notPascalCase: "Function name '{{name}}' should be in PascalCase.",
        },
      },
      create(context) {
        function checkFunctionName(node) {
          const functionName = node.id && node.id.name;

          // Ensure functionName is a string before proceeding
          if (typeof functionName !== 'string') {
            return;
          }

          // Check if function name is in PascalCase
          if (!pascalCase.test(functionName)) {
            context.report({
              node: node.id,
              messageId: 'notPascalCase',
              data: { name: functionName },
            });
          }
        }

        return {
          FunctionDeclaration(node) {
            checkFunctionName(node);
          },
          FunctionExpression(node) {
            if (
              node.parent &&
              node.parent.type === 'VariableDeclarator' &&
              node.parent.id
            ) {
              checkFunctionName(node.parent);
            }
          },
          ArrowFunctionExpression(node) {
            if (
              node.parent &&
              node.parent.type === 'VariableDeclarator' &&
              node.parent.id
            ) {
              checkFunctionName(node.parent);
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/max-function-params.js
================================================
module.exports = {
  rules: {
    'max-function-params': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Limit the number of function parameters to keep functions simple and readable',
          category: 'Best Practices',
          recommended: false,
        },
        schema: [
          {
            type: 'object',
            properties: {
              max: {
                type: 'integer',
                minimum: 0,
              },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          tooManyParameters:
            'Function "{{name}}" has too many parameters ({{count}}). Maximum allowed is {{max}}.',
        },
      },
      create(context) {
        // Default max value
        const defaultMax = 3;

        // Get the max value from options or use default
        const options = context.options[0] || {};
        const max = options.max || defaultMax;

        return {
          FunctionDeclaration(node) {
            const parameterCount = node.params.length;

            if (parameterCount > max) {
              context.report({
                node,
                messageId: 'tooManyParameters',
                data: {
                  name: node.id ? node.id.name : 'Anonymous function',
                  count: parameterCount,
                  max: max,
                },
              });
            }
          },
          FunctionExpression(node) {
            const parameterCount = node.params.length;

            if (parameterCount > max) {
              context.report({
                node,
                messageId: 'tooManyParameters',
                data: {
                  name: 'Anonymous function',
                  count: parameterCount,
                  max: max,
                },
              });
            }
          },
          ArrowFunctionExpression(node) {
            const parameterCount = node.params.length;

            if (parameterCount > max) {
              context.report({
                node,
                messageId: 'tooManyParameters',
                data: {
                  name: 'Anonymous function',
                  count: parameterCount,
                  max: max,
                },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/max-lines-per-file.js
================================================
const path = require('path');

module.exports = {
  rules: {
    'max-lines-per-file': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Restrict the number of lines per file to promote readability and maintainability.',
          category: 'Best Practices',
          recommended: false,
        },
        schema: [
          {
            type: 'object',
            properties: {
              max: {
                type: 'integer',
                default: 500,
                description: 'Maximum number of lines allowed in a file.',
              },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          tooManyLines:
            'File "{{name}}" exceeds the maximum allowed number of {{max}} lines (actual: {{lines}}).',
        },
      },
      create(context) {
        const options = context.options[0] || {};
        const maxLines = options.max || 500;

        function checkFile() {
          const fileLines = context.getSourceCode().lines.length;

          if (fileLines > maxLines) {
            context.report({
              loc: {
                start: { line: 1, column: 0 },
                end: { line: fileLines, column: 0 },
              },
              messageId: 'tooManyLines',
              data: {
                name: path.basename(context.getFilename()),
                max: maxLines,
                lines: fileLines,
              },
            });
          }
        }

        return {
          Program: checkFile,
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/max-lines-per-function.js
================================================
module.exports = {
  rules: {
    'max-lines-per-function': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Restrict the length of functions to promote small, modular functions',
          category: 'Best Practices',
          recommended: false,
        },
        schema: [
          {
            type: 'object',
            properties: {
              max: {
                type: 'integer',
                default: 50,
                description: 'Maximum number of lines allowed in a function.',
              },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          tooManyLines:
            'Function "{{name}}" exceeds the maximum allowed number of {{max}} lines (actual: {{lines}}).',
        },
      },
      create(context) {
        const options = context.options[0] || {};
        const maxLines = options.max || 50;

        function checkFunction(node) {
          const functionBody = node.body;
          if (functionBody.type === 'BlockStatement') {
            const functionLines =
              functionBody.loc.end.line - functionBody.loc.start.line + 1;
            if (functionLines > maxLines) {
              context.report({
                node,
                messageId: 'tooManyLines',
                data: {
                  name: node.id ? node.id.name : 'Anonymous function',
                  max: maxLines,
                  lines: functionLines,
                },
              });
            }
          }
        }

        return {
          FunctionDeclaration: checkFunction,
          FunctionExpression: checkFunction,
          ArrowFunctionExpression: checkFunction,
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/no-single-character-vars.js
================================================
module.exports = {
  rules: {
    'no-single-character-vars': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Disallow single-character variable names declared with var, let, or const',
        },
        schema: [], // No options needed
        messages: {
          singleCharVar:
            "Variable '{{name}}' should not be a single character.",
        },
      },
      create(context) {
        return {
          VariableDeclarator(node) {
            const variableName = node.id && node.id.name;

            // Ensure variableName is a string before proceeding
            if (typeof variableName !== 'string') {
              return;
            }

            // Check if variable name is a single character
            if (variableName.length === 1) {
              context.report({
                node: node.id,
                messageId: 'singleCharVar',
                data: { name: variableName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/vars-camelcase.js
================================================
const camelCase = /^[a-z][a-zA-Z0-9]*$/;

module.exports = {
  rules: {
    'vars-camelcase': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforce camelCase naming convention for variables declared with var, let, or const',
        },
        schema: [], // No options needed
        messages: {
          notCamelCase: "Variable '{{name}}' should be in camelCase.",
        },
      },
      create(context) {
        return {
          VariableDeclarator(node) {
            const variableName = node.id && node.id.name;

            // Ensure variableName is a string before proceeding
            if (typeof variableName !== 'string') {
              return;
            }

            // Check if variable name is in camelCase
            if (!camelCase.test(variableName)) {
              context.report({
                node: node.id,
                messageId: 'notCamelCase',
                data: { name: variableName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/vars-descriptive.js
================================================
const { isVerb } = require('../../../utils/check-verb');

module.exports = {
  rules: {
    'vars-descriptive': {
      meta: {
        type: 'suggestion',
        docs: {
          description:
            'Enforce variable names to start with a verb and be descriptive',
        },
        schema: [], // No options needed
        messages: {
          notDescriptive:
            "Variable name '{{name}}' should start with a verb and be descriptive.",
        },
      },
      create(context) {
        return {
          VariableDeclarator(node) {
            const variableName = node.id && node.id.name;

            // Ensure variableName is a string before proceeding
            if (typeof variableName !== 'string') {
              return;
            }

            // Check if the first word in the camelCase variable is a verb
            const firstWord = variableName.split(/(?=[A-Z])/)[0];
            if (!isVerb(firstWord)) {
              context.report({
                node: node.id,
                messageId: 'notDescriptive',
                data: { name: variableName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/vars-lowercase.js
================================================
const lowerCaseRegex = /^[a-z][a-z0-9]*$/;

module.exports = {
  rules: {
    'vars-lowercase': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforce lowercase naming convention for variables declared with var, let, or const',
        },
        schema: [], // No options needed
        messages: {
          notLowerCase: "Variable '{{name}}' should be in lowercase.",
        },
      },
      create(context) {
        return {
          VariableDeclarator(node) {
            const variableName = node.id && node.id.name;

            // Ensure variableName is a string before proceeding
            if (typeof variableName !== 'string') {
              return;
            }

            // Check if variable name is in lowercase
            if (!lowerCaseRegex.test(variableName)) {
              context.report({
                node: node.id,
                messageId: 'notLowerCase',
                data: { name: variableName },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/vars-pascalcase.js
================================================
module.exports = {
  rules: {
    'vars-pascalcase': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforce PascalCase naming convention for variables declared with var, let, or const',
        },
        fixable: 'code',
        schema: [],
        messages: {
          notPascalCase: "Variable '{{name}}' should be in PascalCase.",
        },
      },
      create(context) {
        return {
          VariableDeclarator(node) {
            const variableName = node.id && node.id.name;

            // Ensure variableName is a string before proceeding
            if (typeof variableName !== 'string') {
              return;
            }

            // Regular expression to check if the variable name is in PascalCase
            const pascalCase = /^[A-Z][a-zA-Z0-9]*$/;

            // Check if the variable name is not in PascalCase
            if (!pascalCase.test(variableName)) {
              context.report({
                node: node.id,
                messageId: 'notPascalCase',
                data: { name: variableName },
                fix: function (fixer) {
                  // Suggest a fix by converting the variable name to PascalCase
                  const pascalCaseName = variableName.replace(
                    /(^\w|_\w)/g,
                    match => match.replace('_', '').toUpperCase()
                  );
                  return fixer.replaceText(node.id, pascalCaseName);
                },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/general/plugin/vars-snakecase.js
================================================
const snakeCasePattern = /^[a-z][a-z0-9_]*$/;

module.exports = {
  rules: {
    'vars-snakecase': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforce snake_case naming convention for variables declared with var, let, or const',
        },
        fixable: 'code',
        schema: [], // No options needed
        messages: {
          notSnakeCase: "Variable '{{name}}' should be in snake_case.",
        },
      },
      create(context) {
        return {
          VariableDeclarator(node) {
            const variableName = node.id && node.id.name;

            // Ensure variableName is a string before proceeding
            if (typeof variableName !== 'string') {
              return;
            }

            // Check if variable name is in snake_case
            if (!snakeCasePattern.test(variableName)) {
              context.report({
                node: node.id,
                messageId: 'notSnakeCase',
                data: { name: variableName },
                fix(fixer) {
                  // Automatically fix the variable name to snake_case
                  const snakeCaseName = variableName
                    .replace(/([A-Z])/g, '_$1') // Add underscores before uppercase letters
                    .toLowerCase() // Convert to lowercase
                    .replace(/^_/, ''); // Remove leading underscore if present

                  return fixer.replaceText(node.id, snakeCaseName);
                },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/node/index.js
================================================
const expressRules = require('./express/index.js');

module.exports = {
  rules: {
    ...expressRules.rules,
  },
};



================================================
File: lib/rules/node/express/index.js
================================================
const openApiSpecRules = require('./open-api-spec/index.js');
// Add other sub-categories of express if any

module.exports = {
  rules: {
    ...openApiSpecRules.rules,
  },
};



================================================
File: lib/rules/node/express/open-api-spec/index.js
================================================
const httpStatusCode = require('./plugin/http-status-code');

module.exports = {
  rules: {
    ...httpStatusCode.rules,
    // ...add other express rules here in the future
  },
};



================================================
File: lib/rules/node/express/open-api-spec/plugin/http-status-code.js
================================================
const knownExpressMethods = new Set([
  'get',
  'post',
  'put',
  'delete',
  'patch',
  'options',
  'head',
  'all',
  'use',
]);
const responseSendMethods = new Set([
  'send',
  'json',
  'end',
  'sendStatus',
  'redirect',
]);
const defaultStatusCodeByMethod = {
  GET: [200],
  POST: [201],
  PUT: [200, 204],
  PATCH: [200, 204],
  DELETE: [200, 204],
  OPTIONS: [200, 204],
  HEAD: [200, 204],
};

module.exports = {
  rules: {
    'http-status-code': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Ensure that Express.js route handlers use appropriate HTTP status codes based on the HTTP method.',
          category: 'Best Practices',
          recommended: true,
        },
        fixable: null,
        schema: [
          {
            type: 'object',
            properties: {
              responseObjectName: {
                type: 'string',
                description:
                  'The name of the response object in route handlers.',
                default: 'res',
              },
              validStatusCodesByMethod: {
                type: 'object',
                description:
                  'Custom mapping of HTTP methods to arrays of allowed status codes.',
                patternProperties: {
                  '^(GET|POST|PUT|DELETE|PATCH|OPTIONS|HEAD|ALL|USE)$': {
                    type: 'array',
                    items: { type: 'integer' },
                    minItems: 1,
                  },
                },
                additionalProperties: false,
              },
            },
            additionalProperties: false,
          },
        ],
        messages: {
          invalidStatusCode:
            'Expected {{responseObjectName}}.status({{expectedCodes}}) for {{httpMethod}} request, but found {{responseObjectName}}.status({{actualCode}}).',
          invalidSendStatusCode:
            'Expected {{responseObjectName}}.sendStatus({{expectedCodes}}) for {{httpMethod}} request, but found {{responseObjectName}}.sendStatus({{actualCode}}).',
        },
      },
      create: function (context) {
        const options = context.options[0] || {};
        const configuredResponseObjectName =
          options.responseObjectName || 'res';
        const validStatusCodesByMethod = {
          ...defaultStatusCodeByMethod,
          ...(options.validStatusCodesByMethod || {}),
        };

        const routeContextStack = [];

        function getStatusCodeFromCall(callExpressionNode) {
          if (
            callExpressionNode.arguments.length > 0 &&
            callExpressionNode.arguments[0].type === 'Literal' &&
            typeof callExpressionNode.arguments[0].value === 'number'
          ) {
            return callExpressionNode.arguments[0].value;
          }
          return null;
        }

        function getRouteContext() {
          return routeContextStack.length > 0
            ? routeContextStack[routeContextStack.length - 1]
            : null;
        }

        return {
          CallExpression(node) {
            // Part 1: Identify route definitions and push context to stack
            if (node.callee.type === 'MemberExpression') {
              const methodName = node.callee.property.name;

              if (knownExpressMethods.has(methodName)) {
                const handlerArg = node.arguments.find(
                  arg =>
                    arg &&
                    (arg.type === 'FunctionExpression' ||
                      arg.type === 'ArrowFunctionExpression')
                );

                if (handlerArg) {
                  let responseObjectNameInHandler =
                    configuredResponseObjectName;
                  if (
                    handlerArg.params &&
                    handlerArg.params.length > 1 &&
                    handlerArg.params[1].type === 'Identifier'
                  ) {
                    responseObjectNameInHandler = handlerArg.params[1].name;
                  } else if (
                    handlerArg.params &&
                    handlerArg.params.length > 0 &&
                    handlerArg.params[0].type === 'Identifier' &&
                    handlerArg.params[0].name === configuredResponseObjectName
                  ) {
                    responseObjectNameInHandler = handlerArg.params[0].name;
                  }

                  routeContextStack.push({
                    httpMethod: methodName.toUpperCase(),
                    responseObjectName: responseObjectNameInHandler,
                    handlerNode: handlerArg,
                  });
                }
              }
            }

            // Part 2: Check for status calls if we are inside a known route handler
            const currentRouteContext = getRouteContext();
            if (
              currentRouteContext &&
              node.callee.type === 'MemberExpression'
            ) {
              let inHandlerScope = false;
              let tempNode = node;
              while (tempNode) {
                if (tempNode === currentRouteContext.handlerNode) {
                  inHandlerScope = true;
                  break;
                }
                tempNode = tempNode.parent;
              }

              if (inHandlerScope) {
                let actualCode = null;
                let reportNode = node; // The CallExpression node being visited (e.g., .send(), .json(), .sendStatus())
                let statusSettingNode = null; // The node that *sets* the status, e.g. .status(XXX) or .sendStatus(XXX)
                let messageId = 'invalidStatusCode';

                // Case 1: res.sendStatus(code)
                if (
                  node.callee.object.type === 'Identifier' &&
                  node.callee.object.name ===
                    currentRouteContext.responseObjectName &&
                  node.callee.property.name === 'sendStatus'
                ) {
                  statusSettingNode = node; // The sendStatus call itself
                  messageId = 'invalidSendStatusCode';
                }
                // Case 2: Patterns ending in .send(), .json(), .end() that might be preceded by .status()
                else if (
                  responseSendMethods.has(node.callee.property.name) &&
                  node.callee.property.name !== 'sendStatus' && // Handled above
                  node.callee.property.name !== 'redirect'
                ) {
                  // Redirects might have different status logic

                  let objectOfSend = node.callee.object;

                  // Check if objectOfSend is itself a CallExpression like someFormOf.status(code)
                  if (
                    objectOfSend.type === 'CallExpression' &&
                    objectOfSend.callee.type === 'MemberExpression' &&
                    objectOfSend.callee.property.name === 'status'
                  ) {
                    // objectOfSend is the LAST .status(code) in the chain before .send()
                    // Now, we need to verify its base is the response object
                    let baseObject = objectOfSend.callee.object;
                    while (
                      baseObject.type === 'CallExpression' &&
                      baseObject.callee.type === 'MemberExpression' &&
                      baseObject.callee.property.name === 'status'
                    ) {
                      baseObject = baseObject.callee.object;
                    }

                    if (
                      baseObject.type === 'Identifier' &&
                      baseObject.name === currentRouteContext.responseObjectName
                    ) {
                      statusSettingNode = objectOfSend;
                    } else {
                    }
                  } else {
                  }
                }

                if (statusSettingNode) {
                  actualCode = getStatusCodeFromCall(statusSettingNode);
                  reportNode =
                    statusSettingNode.arguments.length > 0 &&
                    statusSettingNode.arguments[0].type === 'Literal'
                      ? statusSettingNode.arguments[0]
                      : statusSettingNode;
                }

                if (
                  actualCode !== null &&
                  validStatusCodesByMethod[currentRouteContext.httpMethod]
                ) {
                  const expectedCodes =
                    validStatusCodesByMethod[currentRouteContext.httpMethod];
                  const isErrorCode = actualCode >= 400 && actualCode <= 599;

                  if (!isErrorCode && !expectedCodes.includes(actualCode)) {
                    context.report({
                      node: reportNode,
                      messageId: messageId,
                      data: {
                        responseObjectName:
                          currentRouteContext.responseObjectName,
                        httpMethod: currentRouteContext.httpMethod,
                        actualCode: String(actualCode),
                        expectedCodes: expectedCodes.join(' or '),
                      },
                    });
                  } else {
                  }
                } else if (actualCode !== null) {
                }
              }
            }
          },
          'FunctionExpression:exit'(node) {
            const currentRouteContext = getRouteContext();
            if (
              currentRouteContext &&
              currentRouteContext.handlerNode === node
            ) {
              // const popped = routeContextStack.pop();
            }
          },
          'ArrowFunctionExpression:exit'(node) {
            const currentRouteContext = getRouteContext();
            if (
              currentRouteContext &&
              currentRouteContext.handlerNode === node
            ) {
              // const popped = routeContextStack.pop();
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/react/index.js
================================================
const reactComponentNameMatchFilename = require('./plugin/react-component-name-match-filename');
const reactFilenamePascalCase = require('./plugin/react-filename-pascalcase');

module.exports = {
  rules: {
    ...reactComponentNameMatchFilename.rules,
    ...reactFilenamePascalCase.rules,
  },
};



================================================
File: lib/rules/react/plugin/react-component-name-match-filename.js
================================================
const path = require('path');
const { parse } = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const types = require('@babel/types');

module.exports = {
  rules: {
    'react-component-name-match-filename': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforces that the React component name matches the filename.',
        },
        schema: [],
      },
      create(context) {
        const filenameWithExt = path.basename(context.getFilename());
        const extname = path.extname(filenameWithExt);
        const filename = path.basename(filenameWithExt, extname);

        // List of extensions the rule should apply to
        const validExtensions = ['.js', '.ts', '.jsx', '.tsx'];

        // Ignore files named 'index'
        if (filename === 'index' || !validExtensions.includes(extname)) {
          return {};
        }

        let componentName = null;
        let isReactFileDetected = false;

        return {
          Program() {
            const code = context.getSourceCode().text;
            const ast = parse(code, {
              sourceType: 'module',
              plugins: ['jsx', 'typescript'],
            });

            // Check if the file contains React code
            traverse(ast, {
              ImportDeclaration(path) {
                if (path.node.source.value === 'react') {
                  isReactFileDetected = true;
                }
              },
              JSXOpeningElement() {
                isReactFileDetected = true;
              },
              ExportDefaultDeclaration(path) {
                const declaration = path.node.declaration;
                if (types.isIdentifier(declaration)) {
                  componentName = declaration.name;
                } else if (
                  types.isClassDeclaration(declaration) ||
                  types.isFunctionDeclaration(declaration)
                ) {
                  componentName = declaration.id ? declaration.id.name : null;
                }
              },
              VariableDeclarator(path) {
                if (path.node.id && types.isIdentifier(path.node.id)) {
                  const init = path.node.init;
                  if (
                    types.isArrowFunctionExpression(init) ||
                    types.isFunctionExpression(init)
                  ) {
                    componentName = path.node.id.name;
                  }
                }
              },
              FunctionDeclaration(path) {
                if (path.node.id && types.isIdentifier(path.node.id)) {
                  componentName = path.node.id.name;
                }
              },
            });

            // Only report if this is a React file and the component name does not match the filename
            if (
              isReactFileDetected &&
              componentName &&
              componentName !== filename
            ) {
              context.report({
                node: ast.program,
                message: `Component name '{{name}}' should match the filename '{{filename}}'.`,
                data: {
                  name: componentName,
                  filename: filenameWithExt,
                },
              });
            }
          },
        };
      },
    },
  },
};



================================================
File: lib/rules/react/plugin/react-filename-pascalcase.js
================================================
const path = require('path');

// Function to check if a filename is in PascalCase
function isPascalCase(filename) {
  return /^[A-Z][a-zA-Z0-9]*$/.test(filename);
}

module.exports = {
  rules: {
    'react-filename-pascalcase': {
      meta: {
        type: 'problem',
        docs: {
          description:
            'Enforces PascalCase for filenames in React files (.js, .ts, .jsx, .tsx).',
        },
        schema: [],
      },
      create: function (context) {
        // Get the filename and extension of the file being linted
        const filenameWithExt = path.basename(context.getFilename());
        const extname = path.extname(filenameWithExt);
        const filename = path.basename(filenameWithExt, extname);

        // List of extensions the rule should apply to
        const validExtensions = ['.js', '.ts', '.jsx', '.tsx'];

        // Ignore files named 'index'
        if (filename === 'index' || !validExtensions.includes(extname)) {
          return {};
        }
        // Function to check if the file contains React code
        function isReactFile(node) {
          // Check for React imports or JSX
          return (
            (node.type === 'ImportDeclaration' &&
              node.source.value === 'react') ||
            node.type === 'JSXOpeningElement'
          );
        }

        // Only check files with the specified extensions
        if (validExtensions.includes(extname)) {
          let isReactFileDetected = false;

          return {
            // Listen for imports and JSX to detect if it's a React file
            ImportDeclaration(node) {
              if (isReactFile(node)) {
                isReactFileDetected = true;
              }
            },
            JSXOpeningElement(node) {
              isReactFileDetected = true;
            },
            'Program:exit'() {
              if (isReactFileDetected && !isPascalCase(filename)) {
                context.report({
                  message: `Filename '{{name}}' should be in PascalCase.`,
                  data: {
                    name: filenameWithExt,
                  },
                  loc: { line: 1, column: 1 },
                });
              }
            },
          };
        }

        return {};
      },
    },
  },
};



================================================
File: lib/utils/check-eslint-config.js
================================================
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const readline = require('readline');

// List of possible ESLint config files
const eslintConfigFiles = [
  '.eslintrc.js',
  'eslint.config.js',
  'eslint.config.mjs',
  '.eslintrc.json',
  '.eslintrc.yaml',
  '.eslintrc.yml',
];

// Function to find the project root (where package.json is located)
function findProjectRoot(startDir) {
  let currentDir = startDir;
  while (currentDir !== path.parse(currentDir).root) {
    if (fs.existsSync(path.join(currentDir, 'package.json'))) {
      return currentDir;
    }
    currentDir = path.dirname(currentDir);
  }
  return null;
}

const projectDir = findProjectRoot(process.cwd()) || process.cwd();

// Check if any ESLint configuration file exists
const hasEslintConfig = eslintConfigFiles.some(configFile =>
  fs.existsSync(path.join(projectDir, configFile))
);

if (!hasEslintConfig) {
  console.log(`
    WARNING: No ESLint configuration found in your project.
  `);

  // Set up readline for user input
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  rl.question(
    'Would you like to automatically install ESLint and set up configuration? (y/n): ',
    userResponse => {
      const response = userResponse.toLowerCase();

      if (response === 'y') {
        try {
          // Change to project directory before running commands
          process.chdir(projectDir);

          // Run ESLint configuration setup using npm init @eslint/config@latest
          console.log('Setting up basic ESLint configuration...');
          execSync('npm init @eslint/config@latest', { stdio: 'inherit' });

          console.log(`
            ESLint has been successfully installed and configured!
          
            To customize your setup further, check the eslint.config* file created in your project.
            Don't forget to add "@mindfiredigital/eslint-plugin-hub" to the ESLint configuration file under "plugins".
          
            For more details, visit the npm package page or the official documentation.
          `);
        } catch (error) {
          console.error(
            'An error occurred during the installation or setup process:',
            error.message
          );
        }
      } else {
        console.log(
          'Skipping ESLint setup. Please make sure to configure it manually.'
        );
      }

      rl.close(); // Close the readline interface after the response
    }
  );
} else {
  console.log('ESLint configuration found in your project.');
}



================================================
File: lib/utils/check-verb.js
================================================
const nlp = require('compromise');

function isVerb(word) {
  const doc = nlp(word);
  return doc.verbs().out('array').length > 0;
}

module.exports = {
  isVerb,
};



================================================
File: script/generate-rule.js
================================================
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { ruleTemplate } = require('./templates/rule-template');
const { testTemplate } = require('./templates/test-template');
const { reactTestTemplate } = require('./templates/react-test-template');
const { angularTestTemplate } = require('./templates/angular-test-template');

const ruleName = process.argv[2];

if (!ruleName) {
  console.error('Please provide a rule name.');
  process.exit(1);
}

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Function to convert kebab-case to camelCase
function toCamelCase(str) {
  return str.replace(/-([a-z])/g, g => g[1].toUpperCase());
}

// Function to create files and update index.js
function createRule(ruleType) {
  // Define paths based on rule type
  const rulesDir = path.join(
    __dirname,
    '..',
    'lib',
    'rules',
    ruleType,
    'plugin'
  );
  const ruleFile = path.join(rulesDir, `${ruleName}.js`);
  const testFile = path.join(
    __dirname,
    '..',
    'test',
    ruleType,
    `${ruleName}.test.js`
  );
  const indexFile = path.join(
    __dirname,
    '..',
    'lib',
    'rules',
    ruleType,
    'index.js'
  );

  // Ensure the directory exists
  if (!fs.existsSync(rulesDir)) {
    fs.mkdirSync(rulesDir, { recursive: true });
  }

  // Create rule file
  fs.writeFileSync(ruleFile, ruleTemplate(ruleName).trim(), 'utf8');
  console.log(`Rule file created: ${ruleFile}`);

  // Create test file based on rule type
  let testContent;
  switch (ruleType) {
    case 'react':
      testContent = reactTestTemplate(ruleName);
      break;
    case 'angular':
      testContent = angularTestTemplate(ruleName);
      break;
    default:
      testContent = testTemplate(ruleName);
  }
  fs.writeFileSync(testFile, testContent.trim(), 'utf8');
  console.log(`Test file created: ${testFile}`);

  // Update index.js for the specific rule type
  const indexContent = fs.readFileSync(indexFile, 'utf8');
  const camelCaseRuleName = toCamelCase(ruleName);
  const ruleImport = `const ${camelCaseRuleName} = require('./plugin/${ruleName}');`;

  // New regex pattern to match the entire rules object
  const rulesObjectPattern = /(module\.exports\s*=\s*{\s*rules:\s*{[^}]*})/;

  const updatedIndexContent = indexContent
    .replace(/(const .+ = require\('.+'\);)/, `$1\n${ruleImport}`)
    .replace(rulesObjectPattern, match => {
      // Insert the new rule at the end of the rules object, before the closing brace
      return match.replace(/}(\s*)$/, `  ...${camelCaseRuleName}.rules,\n}$1`);
    });

  fs.writeFileSync(indexFile, updatedIndexContent, 'utf8');
  console.log(`Index file updated: ${indexFile}`);

  rl.close();
}

// Prompt the user to choose between general, react, and angular if ruleType is not provided
if (!process.argv[3]) {
  rl.question(
    'Please choose the rule type (general/react/angular): ',
    answer => {
      const ruleType = answer.toLowerCase();
      if (['general', 'react', 'angular'].includes(ruleType)) {
        createRule(ruleType);
      } else {
        console.error(
          'Invalid rule type. Please choose "general", "react", or "angular".'
        );
        process.exit(1);
      }
    }
  );
} else {
  createRule(process.argv[3]);
}



================================================
File: script/templates/angular-test-template.js
================================================
const angularTestTemplate = ruleName => `
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;
const tsParser = require('@typescript-eslint/parser');

const ruleTester = new RuleTester({
  languageOptions: {
    parser: tsParser,
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run('${ruleName}', rules['${ruleName}'], {
  valid: [
    // Add valid test cases here
  ],
  invalid: [
    {
      // Add Invalid test cases here
    },
  ],
});
`;
module.exports = { angularTestTemplate };



================================================
File: script/templates/react-test-template.js
================================================
const reactTestTemplate = ruleName => `
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;
const babelParser = require('@babel/eslint-parser');

const ruleTester = new RuleTester({
  languageOptions: {
    parser: babelParser,
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run('${ruleName}', rules['${ruleName}'], {
  valid: [
    // Add valid test cases here
  ],
  invalid: [
    {
      // Add Invalid test cases here
    },
  ],
});
`;
module.exports = { reactTestTemplate };



================================================
File: script/templates/rule-template.js
================================================
const ruleTemplate = ruleName => `
module.exports = {
    rules: {
        '${ruleName}': {
            meta: {
                type: "suggestion",
                docs: {
                    description: "Description of the rule",
                },
                fixable: "code",
                schema: [] // no options
            },
            create: function(context) {
                return {
                    // callback functions
                };
            }
        }
    }
};`;

module.exports = { ruleTemplate };



================================================
File: script/templates/test-template.js
================================================
const testTemplate = ruleName => `
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('${ruleName}', rules['${ruleName}'], {
  valid: [
    // Add valid test cases here
  ],
  invalid: [
    {
      // Add Invalid test cases here
    },
  ],
});
`;
module.exports = { testTemplate };



================================================
File: test/advanced/avoid-runtime-heap-allocation.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester({
  languageOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
  },
});

ruleTester.run(
  'avoid-runtime-heap-allocation',
  rules['avoid-runtime-heap-allocation'],
  {
    valid: [
      // Allocations at module scope (outside functions)
      { code: 'const moduleScopeArray = [];' },
      { code: 'const moduleScopeObject = {};' },
      { code: 'const moduleScopeMap = new Map();' },
      { code: 'const moduleScopeSet = new Set();' },

      // Empty arrays/objects as default function parameters (ignored by heuristic)
      { code: 'function foo(arr = []) {}' },
      { code: 'function bar(obj = {}) {}' },
      { code: 'const baz = (arr = []) => {};' },

      // Allocations inside functions when 'checkLoopsOnly' is true and not in a loop
      {
        code: 'function allocateNoLoop() { const arr = []; const obj = {}; const m = new Map(); }',
        options: [{ checkLoopsOnly: true }],
      },

      // Allocations of 'allowedConstructs'
      {
        code: 'function allocateAllowed() { const m = new Map(); const s = new Set(); }',
        options: [{ allowedConstructs: ['Map', 'Set'] }],
      },
      {
        code: 'function allocateAllowedInLoop() { for(let i=0; i<1; i++) { const m = new Map(); } }',
        options: [{ allowedConstructs: ['Map'] }],
      },
      // This test case was previously problematic due to combined errors. It's now for an invalid scenario.
      // We will test the "allowedConstructs" logic with an explicit invalid case below.

      // Function returning an array/object - valid if checkLoopsOnly=true or if construct is allowed
      {
        code: 'function createArray() { return []; }',
        options: [{ checkLoopsOnly: true }],
      },
      {
        code: 'function createObject() { return {}; }',
        options: [{ allowedConstructs: ['Object'] }],
      },
      {
        // Moved from invalid: This pattern is valid according to the rule's logic
        code: `const reusableBuffer = [];
                   function processIncomingData(newData) {
                     reusableBuffer.length = 0;
                     reusableBuffer.push(...newData);
                   }`,
      },
    ],
    invalid: [
      // Moved from valid: This should be flagged by the rule's current logic
      {
        code: 'let a; function init() { a = []; } init();',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Array',
              functionName: 'init',
              nodeText: '[]',
            },
            type: 'ArrayExpression',
          },
        ],
      },
      // --- Allocations in Function (checkLoopsOnly = false by default) ---
      {
        code: 'function funcArray() { const arr = [1, 2]; }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Array',
              functionName: 'funcArray',
              nodeText: '[1, 2]',
            },
            type: 'ArrayExpression',
          },
        ],
      },
      {
        code: 'function funcObject() { const obj = { a: 1 }; }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Object',
              functionName: 'funcObject',
              nodeText: '{ a: 1 }',
            },
            type: 'ObjectExpression',
          },
        ],
      },
      {
        code: 'function funcNewArray() { const arr = new Array(); }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Array',
              functionName: 'funcNewArray',
              nodeText: 'new Array()',
            },
            type: 'NewExpression',
          },
        ],
      },
      {
        code: 'function funcNewObject() { const obj = new Object(); }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Object',
              functionName: 'funcNewObject',
              nodeText: 'new Object()',
            },
            type: 'NewExpression',
          },
        ],
      },
      {
        code: 'function funcNewMap() { const m = new Map(); }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Map',
              functionName: 'funcNewMap',
              nodeText: 'new Map()',
            },
            type: 'NewExpression',
          },
        ],
      },
      {
        code: 'function funcNewSet() { const s = new Set(); }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Set',
              functionName: 'funcNewSet',
              nodeText: 'new Set()',
            },
            type: 'NewExpression',
          },
        ],
      },
      {
        code: 'function funcNewWeakMap() { const wm = new WeakMap(); }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'WeakMap',
              functionName: 'funcNewWeakMap',
              nodeText: 'new WeakMap()',
            },
            type: 'NewExpression',
          },
        ],
      },
      {
        code: 'function funcNewWeakSet() { const ws = new WeakSet(); }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'WeakSet',
              functionName: 'funcNewWeakSet',
              nodeText: 'new WeakSet()',
            },
            type: 'NewExpression',
          },
        ],
      },
      {
        code: 'const arrowFuncAlloc = () => { const arr = []; };',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Array',
              functionName: 'arrowFuncAlloc',
              nodeText: '[]',
            },
            type: 'ArrayExpression',
          },
        ],
      },
      {
        code: 'const exprFuncAlloc = function() { const obj = {}; };',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Object',
              functionName: 'exprFuncAlloc',
              nodeText: '{}',
            },
            type: 'ObjectExpression',
          },
        ],
      },
      {
        code: 'class MyClass { myMethod() { const arr = []; } }',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Array',
              functionName: 'myMethod',
              nodeText: '[]',
            },
            type: 'ArrayExpression',
          },
        ],
      },
      {
        code: 'const myObj = { myMethod() { const arr = []; } };',
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Array',
              functionName: 'myMethod',
              nodeText: '[]',
            },
            type: 'ArrayExpression',
          },
        ],
      },

      // --- Allocations in Loop (checkLoopsOnly = false by default OR true) ---
      {
        code: 'function loopArray() { for(let i=0; i<5; i++) { const arr = [i]; } }',
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Array',
              functionName: 'loopArray',
              nodeText: '[i]',
            },
            type: 'ArrayExpression',
          },
        ],
      },
      {
        code: 'function loopObject(items) { for(const item of items) { const obj = { item }; } }',
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Object',
              functionName: 'loopObject',
              nodeText: '{ item }',
            },
            type: 'ObjectExpression',
          },
        ],
      },
      {
        code: 'function loopNewArray() { let x=0; while(x<2){ const arr = new Array(x); x++;} }',
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Array',
              functionName: 'loopNewArray',
              nodeText: 'new Array(x)',
            },
            type: 'NewExpression',
          },
        ],
      },
      {
        code: 'function loopNewMap() { let c=true; do { const m = new Map(); c=false; } while(c) }',
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Map',
              functionName: 'loopNewMap',
              nodeText: 'new Map()',
            },
            type: 'NewExpression',
          },
        ],
      },
      {
        code: 'function outerLoop() { function inner() { for(let i=0;i<1;i++){ const s = new Set();}} inner(); }',
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Set',
              functionName: 'inner',
              nodeText: 'new Set()',
            },
            type: 'NewExpression',
          },
        ],
      },

      // --- Test options: checkLoopsOnly = true ---
      {
        code: 'function loopArrayOpt() { for(let i=0; i<5; i++) { const arr = [i]; } }',
        options: [{ checkLoopsOnly: true }],
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Array',
              functionName: 'loopArrayOpt',
              nodeText: '[i]',
            },
            type: 'ArrayExpression',
          },
        ],
      },
      {
        code: 'function loopObjectOpt(items) { for(const item of items) { const obj = { item }; } }',
        options: [{ checkLoopsOnly: true }],
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Object',
              functionName: 'loopObjectOpt',
              nodeText: '{ item }',
            },
            type: 'ObjectExpression',
          },
        ],
      },
      {
        code: 'function loopNewMapOpt() { let c=true; do { const m = new Map(); c=false; } while(c) }',
        options: [{ checkLoopsOnly: true }],
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Map',
              functionName: 'loopNewMapOpt',
              nodeText: 'new Map()',
            },
            type: 'NewExpression',
          },
        ],
      },

      // --- Test options: allowedConstructs ---
      {
        // Array allocation in loop, but Map is allowed (Array should still be flagged)
        code: 'function allocateNonAllowedInLoop() { for(let i=0; i<1; i++) { const arr = []; } }',
        options: [{ allowedConstructs: ['Map'] }],
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Array',
              functionName: 'allocateNonAllowedInLoop',
              nodeText: '[]',
            },
          },
        ],
      },
      {
        // Array allocation in function, Map is allowed (Array should still be flagged)
        code: 'function mixedAllowedFunc() { const arr = []; const m = new Map(); }',
        options: [{ allowedConstructs: ['Map'] }],
        errors: [
          {
            messageId: 'allocationInFunction',
            data: {
              constructType: 'Array',
              functionName: 'mixedAllowedFunc',
              nodeText: '[]',
            },
            type: 'ArrayExpression',
          },
        ],
      },
      {
        // Original "DON'T" example from problem statement
        code: `function handleLargeBatch(batch) {
                     for (let i = 0; i < batch.length; i++) {
                       const tempArray = [batch[i]];
                     }
                   }`,
        errors: [
          {
            messageId: 'allocationInLoop',
            data: {
              constructType: 'Array',
              functionName: 'handleLargeBatch',
              nodeText: '[batch[i]]',
            },
            type: 'ArrayExpression',
          },
        ],
      },
    ],
  }
);



================================================
File: test/advanced/check-return-values.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester({
  languageOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
  },
});

const ruleName = 'check-return-values';
const rule = rules[ruleName];

if (!rule) {
  throw new Error(`Rule "${ruleName}" not found. Check plugin export.`);
}

ruleTester.run(ruleName, rule, {
  valid: [
    // Value used
    {
      code: 'const result = someFunction();',
    },
    {
      code: 'let success; success = anotherFunction();',
    },
    {
      code: 'if (checkStatus()) { console.log("OK"); }',
    },
    {
      code: 'const arr = [getValue(), 1];',
    },
    {
      code: 'const obj = { prop: getProp() };',
    },
    {
      code: 'function main() { return process(); }',
    },
    {
      code: 'const val = () => returnsSomething();',
    },
    {
      code: 'console.log(formatData());',
    },
    {
      code: 'const x = 1 + calculate();',
    },
    {
      code: 'const y = ok() && notOk();',
    },
    {
      code: 'const z = !isDisabled();',
    },
    {
      code: 'async function f() { await asyncCall(); }',
    },
    {
      code: 'async function f2() { const res = await asyncCall(); }',
    },
    { code: 'void Math.random();' },
    {
      code: 'const result = Math.random();',
    },
    {
      code: 'void db.logAuditTrail();',
    },
    {
      code: '_ = db.performSideEffect();',
    },
    {
      code: '// return value intentionally ignored\ndb.update(record);',
    },
    {
      code: 'db.update(record); // return value intentionally ignored',
    },
    {
      code: `function updateRecordInDB(record) {
         const success = db.update(record);
         if (!success) {
           console.error('Update failed for record:', record.id);
         }
       }`,
    },
    {
      code: 'const res = obj.method1().method2();',
    },
    {
      code: 'const resultOfLongChain = obj.method1().method2.method3();',
    },
    {
      code: 'new MyClass(arg1, constructorCall());',
    },
    {
      code: 'const template = `value: ${getTemplateValue()}`;',
    },
    {
      code: 'async function test() { await someAsyncFunction(); }',
    },
    {
      code: 'function* gen() { yield getValue(); }',
    },
    {
      code: 'const arrSpread = [...getArray()];',
    },
    {
      code: 'const objSpread = { ...getObject() };',
    },
    {
      code: `
        /* return value intentionally ignored */
        service.call();`,
    },
  ],
  invalid: [
    {
      code: 'someFunction();',
      errors: [
        {
          messageId: 'returnValueNotHandled',
          data: { functionName: 'someFunction' },
        },
      ],
    },
    {
      code: 'db.update(record);',
      errors: [
        {
          messageId: 'returnValueNotHandled',
          data: { functionName: 'db.update' },
        },
      ],
    },
    {
      code: 'Math.random();',
      errors: [
        {
          messageId: 'returnValueNotHandled',
          data: { functionName: 'Math.random' },
        },
      ],
    },
    {
      code: `
        // This comment is not for the line below
        anotherFunction();`,
      errors: [
        {
          messageId: 'returnValueNotHandled',
          data: { functionName: 'anotherFunction' },
        },
      ],
    },
    {
      code: `function updateRecordInDB(record) {
                db.update(record); 
              }`,
      errors: [
        {
          messageId: 'returnValueNotHandled',
          data: { functionName: 'db.update' },
        },
      ],
    },
    {
      code: 'obj.method1().method2();',
      errors: [
        {
          messageId: 'returnValueNotHandled',
          data: { functionName: 'obj.method1().method2' },
        },
      ],
    },
    {
      code: 'obj.method1().method2.method3();',
      errors: [
        {
          messageId: 'returnValueNotHandled',
          data: { functionName: 'obj.method1().method2.method3' },
        },
      ],
    },
    {
      code: `
        /* this is some other block comment */
        service.call();`,
      errors: [
        {
          messageId: 'returnValueNotHandled',
          data: { functionName: 'service.call' },
        },
      ],
    },
  ],
});



================================================
File: test/advanced/fixed-loop-bound.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules; // Assuming your new rule is in the general rules index
// If it's in a 'node' specific index, adjust the require path above or how 'rules' is obtained.
// For example: const nodeRules = require('../../lib/rules/node/index').rules;
// And then use: nodeRules['fixed-loop-bounds']

const ruleTester = new RuleTester({
  languageOptions: {
    ecmaVersion: 2022,
  },
});

ruleTester.run('fixed-loop-bounds', rules['fixed-loop-bounds'], {
  valid: [
    // Standard for loop
    'for (let i = 0; i < 10; i++) { console.log(i); }',
    // While loop with condition modified internally
    'let flag = true; while (flag) { if (Math.random() > 0.5) flag = false; }',
    'let c = 0; while (c < 5) { c++; }',
    // While(true) with a break
    'while (true) { if (Math.random() > 0.5) break; }',
    // For(;;) with a break
    'for (;;) { if (Math.random() > 0.5) break; }',
    // For(;true;) with a break
    'for (;true;) { if (Math.random() > 0.5) break; }',
    // Do-while with condition modified
    'let x = 0; do { x++; } while (x < 5);',
    // Do-while(true) with a break
    'do { if (Math.random() > 0.5) break; } while (true);',
    // For-of and For-in are generally bounded
    'for (const item of [1,2,3]) { console.log(item); }',
    'const obj = {a:1}; for (const key in obj) { console.log(key); }',
    // Flag modified in loop (negated condition)
    'let keepGoing = true; while (!keepGoing === false) { keepGoing = false; }', // This condition is a bit odd but `keepGoing` is modified
    {
      code: 'let run = true; while(run) { if (someCondition()) { run = false; } }',
      options: [{ disallowExternalFlagLoops: true }],
    },
    {
      // <<< THIS WAS THE PROBLEMATIC LINE, NOW FIXED
      code: 'let active = true; function checkStatus() { return Math.random() > 0.5; } while(active) { active = checkStatus(); }',
      // Assumed checkStatus could return false, so 'active' is considered modified.
      options: [{ disallowExternalFlagLoops: true }],
    },
    // Break in a nested block but for the correct loop
    'while(true) { if (true) { if (false) {} else { break; } } }',
    // Labeled break
    `
    outer: while (true) {
        inner: while(true) {
            if (someCondition) break outer;
            if (otherCondition) break inner;
        }
    }
    `,
  ],
  invalid: [
    {
      code: 'while (true) { console.log("infinite"); }',
      errors: [{ messageId: 'infiniteWhileTrueLoop' }], // Ensure this messageId matches your rule
    },
    {
      code: 'for (;;) { console.log("infinite"); }',
      errors: [{ messageId: 'infiniteForLoopNoTest' }], // Ensure this messageId matches
    },
    {
      code: 'for (;true;) { console.log("infinite"); }',
      errors: [{ messageId: 'infiniteForLoopTrueTest' }], // Ensure this messageId matches
    },
    {
      code: 'do { console.log("infinite"); } while (true);',
      errors: [{ messageId: 'infiniteDoWhileTrueLoop' }], // Ensure this messageId matches
    },
    {
      code: 'let externalFlag = true; while (externalFlag) { console.log("looping"); }',
      options: [{ disallowExternalFlagLoops: true }],
      errors: [
        {
          messageId: 'externalFlagWhileLoop', // Ensure this messageId matches
          data: { flagName: 'externalFlag' },
        },
      ],
    },
    {
      code: 'let anotherFlag = true; function loop() { while (anotherFlag) { console.log("loop"); } }',
      options: [{ disallowExternalFlagLoops: true }],
      errors: [
        {
          messageId: 'externalFlagWhileLoop', // Ensure this messageId matches
          data: { flagName: 'anotherFlag' },
        },
      ],
    },
    {
      code: 'let stop = false; while (!stop) { /* stop not changed */ }',
      options: [{ disallowExternalFlagLoops: true }],
      errors: [
        { messageId: 'externalFlagWhileLoop', data: { flagName: 'stop' } }, // Ensure this messageId matches
      ],
    },
    {
      code: 'let condition = true; do { console.log("body"); } while (condition);',
      options: [{ disallowExternalFlagLoops: true }],
      errors: [
        {
          messageId: 'externalFlagDoWhileLoop', // Ensure this messageId matches
          data: { flagName: 'condition' },
        },
      ],
    },
    // disallowInfiniteWhile: false, but external flag loop is still caught
    {
      code: 'let flag = true; while (flag) { }',
      options: [
        { disallowInfiniteWhile: false, disallowExternalFlagLoops: true },
      ],
      errors: [
        { messageId: 'externalFlagWhileLoop', data: { flagName: 'flag' } }, // Ensure this messageId matches
      ],
    },
    // disallowExternalFlagLoops: false, but while(true) is still caught
    {
      code: 'while(true) { }',
      options: [
        { disallowInfiniteWhile: true, disallowExternalFlagLoops: false },
      ],
      errors: [{ messageId: 'infiniteWhileTrueLoop' }], // Ensure this messageId matches
    },
    // Break in nested loop, does not save outer while(true)
    {
      code: 'while(true) { for(let i=0;i<1;i++) { break; } }',
      errors: [{ messageId: 'infiniteWhileTrueLoop' }], // Ensure this messageId matches
    },
    // Break in switch, does not save outer while(true)
    {
      code: 'while(true) { switch(val) { case 1: break; default: foo(); } }',
      errors: [{ messageId: 'infiniteWhileTrueLoop' }], // Ensure this messageId matches
    },
  ],
});



================================================
File: test/advanced/keep-functions-concise.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules; // Adjust if your rules object is structured differently

const ruleTester = new RuleTester({
  languageOptions: {
    ecmaVersion: 2021,
    sourceType: 'module',
  },
});

function generateLines(count) {
  let lines = '';
  for (let i = 0; i < count; i++) {
    lines += `  let var${i};\n`; // Unique variable names
  }
  return lines;
}

ruleTester.run('keep-functions-concise', rules['keep-functions-concise'], {
  valid: [
    // Default options (maxLines: 60, skipBlankLines: false, skipComments: false)
    { code: 'function short() {\n  let a = 1;\n  return a;\n}' }, // 2 lines
    { code: `function with50Lines() {\n${generateLines(50)}}` },

    // Custom maxLines
    {
      code: 'function tiny() {\n  let a = 1;\n}', // 1 line
      options: [{ maxLines: 1 }],
    },

    // skipBlankLines: true
    {
      code: 'function withBlanks() {\n\n  let a = 1;\n\n  let b = 2;\n\n}', // 2 effective lines
      options: [{ maxLines: 2, skipBlankLines: true }],
    },
    {
      code: 'function withBlanksAndCode() {\n  let a = 1;\n\n  let b = 2;\n}', // 2 effective lines
      options: [{ maxLines: 2, skipBlankLines: true }],
    },

    // skipComments: true
    {
      code: 'function withComments() {\n  // comment1\n  let a = 1;\n  /* block comment */\n  let b = 2;\n  // comment2\n}', // 2 effective lines
      options: [{ maxLines: 2, skipComments: true }],
    },
    {
      code: 'function withOnlyComments() {\n  // comment1\n  // comment2\n  /* block comment */\n}', // 0 effective lines
      options: [{ maxLines: 0, skipComments: true }],
    },
    {
      code: 'function withCodeAndComments() {\n  let a = 1; // line comment\n  /* block */ let b = 2;\n}', // 2 effective lines (assuming comments don't make line purely comment)
      options: [{ maxLines: 2, skipComments: true }],
    },

    // skipBlankLines: true, skipComments: true
    {
      code: 'function withAll() {\n  // comment1\n\n  let a = 1;\n\n  /* block comment */\n  let b = 2;\n\n  // comment2\n}', // 2 effective lines
      options: [{ maxLines: 2, skipBlankLines: true, skipComments: true }],
    },

    // Arrow function with concise body
    { code: 'const conciseArrow = () => 1;', options: [{ maxLines: 1 }] },
    { code: 'const conciseArrowOk = () => 1;', options: [{ maxLines: 1 }] }, // Valid as concise body is 1 line
  ],
  invalid: [
    // Default options
    {
      code: `function long() {\n${generateLines(61)}}`, // 61 lines
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'long',
            actualLines: 61,
            maxLines: 60,
            skippedLineInfo: '(no lines skipped by options)',
          },
        },
      ],
    },

    {
      code: 'const conciseArrowZeroMax = () => 1;',
      options: [{ maxLines: 0 }],
      errors: 1,
    },

    // Custom maxLines
    {
      code: 'function tooBig() {\n  let a = 1;\n  let b = 2;\n}', // 2 lines
      options: [{ maxLines: 1 }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'tooBig',
            actualLines: 2,
            maxLines: 1,
            skippedLineInfo: '(no lines skipped by options)',
          },
        },
      ],
    },

    // skipBlankLines: true, but still too many effective lines
    {
      code: 'function longWithBlanks() {\n\n  let a = 1;\n\n  let b = 2;\n  let c = 3;\n\n}', // 3 effective lines
      options: [{ maxLines: 2, skipBlankLines: true }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'longWithBlanks',
            actualLines: 3,
            maxLines: 2,
            skippedLineInfo: '(blank lines skipped)',
          },
        },
      ],
    },
    // Counting blank lines when skipBlankLines: false
    {
      code: 'function countBlanks() {\n  let a = 1;\n\n  let b = 2;\n}', // 3 lines (1 blank)
      options: [{ maxLines: 2, skipBlankLines: false }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'countBlanks',
            actualLines: 3,
            maxLines: 2,
            skippedLineInfo: '(no lines skipped by options)',
          },
        },
      ],
    },

    // skipComments: true, but still too many effective lines
    {
      code: 'function longWithComments() {\n  // comment \n  let a = 1;\n  /* block */\n  let b = 2;\n  let c = 3;\n}', // 3 effective lines
      options: [{ maxLines: 2, skipComments: true }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'longWithComments',
            actualLines: 3,
            maxLines: 2,
            skippedLineInfo: '(comment lines skipped)',
          },
        },
      ],
    },
    // Counting comment lines when skipComments: false
    {
      code: 'function countComments() {\n  // comment\n  let a = 1;\n}', // 2 lines (1 comment)
      options: [{ maxLines: 1, skipComments: false }], // default for skipComments
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'countComments',
            actualLines: 2,
            maxLines: 1,
            skippedLineInfo: '(no lines skipped by options)',
          },
        },
      ],
    },

    // skipBlankLines: true, skipComments: true, but still too many
    {
      code: 'function longWithAll() {\n  // comment\n\n  let a = 1;\n  /* block */\n\n  let b = 2;\n  let c = 3;\n}', // 3 effective lines
      options: [{ maxLines: 2, skipBlankLines: true, skipComments: true }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'longWithAll',
            actualLines: 3,
            maxLines: 2,
            skippedLineInfo: '(blank lines skipped, comment lines skipped)',
          },
        },
      ],
    },
    // Arrow function with concise body, maxLines: 0
    {
      code: 'const conciseArrowTooLong = () => 1;',
      options: [{ maxLines: 0 }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'conciseArrowTooLong',
            actualLines: 1,
            maxLines: 0,
            skippedLineInfo: '(concise body counted as 1 line)',
          },
        },
      ],
    },
  ],
});

// A specific valid case that was marked invalid in thought process, ensuring it's valid.
ruleTester.run(
  'keep-functions-concise (concise arrow valid specific)',
  rules['keep-functions-concise'],
  {
    valid: [
      {
        code: 'const conciseArrowZeroMax = () => 1;',
        options: [{ maxLines: 1 }],
      },
    ],
    invalid: [],
  }
);



================================================
File: test/advanced/limit-data-scope.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester({
  languageOptions: {
    ecmaVersion: 2021,
    sourceType: 'module',
    globals: {
      window: 'writable',
      global: 'writable',
      globalThis: 'writable',
      document: 'readonly',
      crypto: 'readonly',
      process: 'readonly',
      navigator: 'readonly',
      location: 'readonly',
      setTimeout: 'readonly',
      getWindow: 'readonly',
      alert: 'readonly',
      console: 'readonly',
    },
  },
});

ruleTester.run('limit-data-scope', rules['limit-data-scope'], {
  valid: [
    // Valid for "No Global Object Modification"
    { code: 'const myVar = {}; myVar.prop = 1;' },
    { code: 'function foo() { let window = {}; window.bar = 1; }' },
    { code: 'function bar() { let global = {}; global.test = 2; }' },
    { code: 'const obj = { window: {} }; obj.window.prop = 1;' },
    { code: 'let globalThis = {}; globalThis.custom = true;' },
    { code: 'const config = window.location || {};' },
    { code: 'console.log(global.process);' },
    { code: 'const val = globalThis.crypto;' },

    {
      // Variable used in multiple functions - should stay at module level
      code: `
        const sharedVar = 10;
        function funcA() { console.log(sharedVar); }
        function funcB() { console.log(sharedVar); }
      `,
    },
    {
      // Variable used at module scope and in function - should stay at module level
      code: `
        const moduleVar = 20;
        console.log(moduleVar); // Used at module scope
        function useIt() { console.log(moduleVar); }
      `,
    },
    {
      // Variable already in narrowest scope
      code: `
        function doSomething() {
          const localVar = 30; // Already narrowest scope
          console.log(localVar);
        }
      `,
    },
    {
      // Variable used in nested scopes within same function
      code: `
        function outer() {
          const outerVar = 'test';
          if (true) {
            console.log(outerVar);
          }
          for (let i = 0; i < 1; i++) {
            console.log(outerVar);
          }
        }
      `,
    },
    {
      // Imported variables should not be flagged
      code: `import { someFunction } from 'module'; someFunction();`,
    },
    {
      // Function parameters should not be flagged
      code: `
        function test(param) {
          function inner() {
            console.log(param);
          }
          inner();
        }
      `,
    },
    {
      // Variable used in function but also assigned at module level
      code: `
        let config = { default: true };
        function setup() {
          console.log(config);
        }
        config = { updated: true }; // Also used at module level
      `,
    },

    // Valid for "Discourage var" (i.e., uses let/const) ===
    { code: 'let x = 1;' },
    { code: 'const y = 2;' },
    { code: 'for (let i = 0; i < 5; i++) {}' },
    { code: 'function test() { const local = 1; return local; }' },
    { code: 'if (true) { let blockScoped = true; }' },
  ],

  invalid: [
    // Invalid for "No Global Object Modification" ===
    {
      code: 'window.myCustomProperty = 123;',
      errors: [
        {
          messageId: 'noModifyGlobal',
          data: { objectName: 'window', propertyName: 'myCustomProperty' },
        },
      ],
    },
    {
      code: 'global.debug = true;',
      errors: [
        {
          messageId: 'noModifyGlobal',
          data: { objectName: 'global', propertyName: 'debug' },
        },
      ],
    },
    {
      code: 'globalThis["newProperty"] = "value";',
      errors: [
        {
          messageId: 'noModifyGlobal',
          data: { objectName: 'globalThis', propertyName: 'newProperty' },
        },
      ],
    },
    {
      code: 'window[dynamicKey] = result;',
      errors: [
        {
          messageId: 'noModifyGlobal',
          data: { objectName: 'window', propertyName: 'dynamicKey' },
        },
      ],
    },
    {
      code: 'global.process.env.NODE_ENV = "test";',
      errors: [
        {
          messageId: 'noModifyGlobal',
          data: { objectName: 'global', propertyName: 'process' },
        },
      ],
    },
    {
      code: 'function setup() { window.customHandler = function() {}; }',
      errors: [
        {
          messageId: 'noModifyGlobal',
          data: { objectName: 'window', propertyName: 'customHandler' },
        },
      ],
    },
    {
      code: 'globalThis[42] = "answer";',
      errors: [
        {
          messageId: 'noModifyGlobal',
          data: { objectName: 'globalThis', propertyName: '42' },
        },
      ],
    },

    // Invalid for "Narrowest Scope" ===
    {
      code: `
        const onlyInFuncA = 100; // Declared at module scope
        function funcA() {
          console.log(onlyInFuncA); // Only used here
        }
        function funcB() { /* does not use it */ }
      `,
      errors: [
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'onlyInFuncA',
            declarationScopeType: 'module',
            usageScopeType: 'function',
            usageScopeIdentifier: 'funcA',
          },
        },
      ],
    },
    {
      code: `
        let configValue;
        function initialize() {
          configValue = { setting: true };
          console.log(configValue);
        }
      `,
      errors: [
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'configValue',
            declarationScopeType: 'module',
            usageScopeType: 'function',
            usageScopeIdentifier: 'initialize',
          },
        },
      ],
    },
    {
      code: `var scriptVar = "hello"; function greet() { alert(scriptVar); }`,
      languageOptions: { sourceType: 'script' },
      errors: [
        {
          messageId: 'useLetConst',
          data: { variableName: 'scriptVar' },
        },
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'scriptVar',
            declarationScopeType: 'global',
            usageScopeType: 'function',
            usageScopeIdentifier: 'greet',
          },
        },
      ],
    },
    {
      // Variable only used in one anonymous function
      code: `
        const helperData = { value: 42 };
        (function() {
          console.log(helperData.value);
        })();
      `,
      errors: [
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'helperData',
            declarationScopeType: 'module',
            usageScopeType: 'function',
            usageScopeIdentifier: '[anonymous_function]',
          },
        },
      ],
    },
    {
      // Variable only used in arrow function assigned to variable
      code: `
        const apiKey = 'secret123';
        const makeRequest = () => {
          return fetch('/api', { headers: { 'API-Key': apiKey } });
        };
      `,
      errors: [
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'apiKey',
            declarationScopeType: 'module',
            usageScopeType: 'function',
            usageScopeIdentifier: 'makeRequest',
          },
        },
      ],
    },
    {
      // Variable only used in method
      code: `
        let cache = new Map();
        const service = {
          getData: function() {
            if (cache.has('key')) return cache.get('key');
            const data = 'computed';
            cache.set('key', data);
            return data;
          }
        };
      `,
      errors: [
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'cache',
            declarationScopeType: 'module',
            usageScopeType: 'function',
            usageScopeIdentifier: 'getData',
          },
        },
      ],
    },
    {
      // Multiple variables, each only used in one function
      code: `
        const dataA = 'for function A';
        const dataB = 'for function B';
        
        function processA() {
          console.log(dataA);
        }
        
        function processB() {
          console.log(dataB);
        }
      `,
      errors: [
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'dataA',
            declarationScopeType: 'module',
            usageScopeType: 'function',
            usageScopeIdentifier: 'processA',
          },
        },
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'dataB',
            declarationScopeType: 'module',
            usageScopeType: 'function',
            usageScopeIdentifier: 'processB',
          },
        },
      ],
    },

    // Invalid for "Discourage var" ===
    {
      code: 'var z = 3;',
      errors: [{ messageId: 'useLetConst', data: { variableName: 'z' } }],
    },
    {
      code: 'function oldStyle() { var count = 0; return count; }',
      errors: [{ messageId: 'useLetConst', data: { variableName: 'count' } }],
    },
    {
      code: 'var a = 1, b = 2;', // Multiple declarations
      errors: [{ messageId: 'useLetConst', data: { variableName: 'a' } }],
    },
    {
      code: 'for (var i = 0; i < 10; i++) { console.log(i); }',
      errors: [{ messageId: 'useLetConst', data: { variableName: 'i' } }],
    },
    {
      code: 'if (true) { var blockVar = "should be let"; }',
      errors: [
        { messageId: 'useLetConst', data: { variableName: 'blockVar' } },
      ],
    },
    {
      code: 'var func = function() { return "prefer const"; };',
      errors: [{ messageId: 'useLetConst', data: { variableName: 'func' } }],
    },

    // === Combined violations ===
    {
      code: `
    var utilityData = { helper: true };
    function doWork() {
      window.workResult = utilityData.helper;
    }
  `,
      errors: [
        {
          messageId: 'useLetConst',
          data: { variableName: 'utilityData' },
        },
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'utilityData',
            declarationScopeType: 'module',
            usageScopeType: 'function',
            usageScopeIdentifier: 'doWork',
          },
        },
        {
          messageId: 'noModifyGlobal',
          data: { objectName: 'window', propertyName: 'workResult' },
        },
      ],
    },

    {
      code: `
    var appConfig = { debug: false };
    var userPrefs = { theme: 'dark' };

    function initialize() {
      console.log(appConfig);
    }

    function setupUI() {
      console.log(userPrefs);
    }
  `,
      languageOptions: { sourceType: 'script' },
      errors: [
        {
          messageId: 'useLetConst',
          data: { variableName: 'appConfig' },
        },
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'appConfig',
            declarationScopeType: 'global',
            usageScopeType: 'function',
            usageScopeIdentifier: 'initialize',
          },
        },
        {
          messageId: 'useLetConst',
          data: { variableName: 'userPrefs' },
        },
        {
          messageId: 'moveToNarrowerScope',
          data: {
            variableName: 'userPrefs',
            declarationScopeType: 'global',
            usageScopeType: 'function',
            usageScopeIdentifier: 'setupUI',
          },
        },
      ],
    },
  ],
});



================================================
File: test/advanced/limit-reference-depth.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester({
  languageOptions: {
    ecmaVersion: 2021,
    sourceType: 'module',
  },
});

ruleTester.run('limit-reference-depth', rules['limit-reference-depth'], {
  valid: [
    // Default options: maxDepth: 3, requireOptionalChaining: true, allowSinglePropertyAccess: false

    // Single property access with allowSinglePropertyAccess: true
    { code: 'obj.a;', options: [{ allowSinglePropertyAccess: true }] },

    // Optional chaining from the start (NEW BEHAVIOR)
    { code: 'obj?.a;' },
    { code: 'obj?.a?.b;' },
    { code: 'obj?.a?.b?.c;' },
    { code: 'item?.details?.name;' }, // This matches the requirement example

    // Computed properties with optional chaining
    { code: 'obj?.[a];' },
    { code: 'obj?.[a]?.[b];' },
    { code: 'obj?.[a]?.[b]?.[c];' },

    // Function calls with optional chaining
    { code: 'getObj()?.a;' },
    { code: 'getObj()?.a?.b;' },
    { code: 'getObj()?.a?.b?.c;' },

    // this with optional chaining
    { code: 'this?.a?.b?.c;' },

    // When requireOptionalChaining is false
    { code: 'obj.a;', options: [{ requireOptionalChaining: false }] },
    { code: 'obj.a.b;', options: [{ requireOptionalChaining: false }] },
    { code: 'obj.a.b.c;', options: [{ requireOptionalChaining: false }] },
    { code: 'this.a;', options: [{ requireOptionalChaining: false }] },
    { code: 'getObj().a;', options: [{ requireOptionalChaining: false }] },

    // Custom maxDepth with optional chaining
    { code: 'obj?.a;', options: [{ maxDepth: 1 }] },
    { code: 'obj?.a?.b;', options: [{ maxDepth: 2 }] },

    // Backward compatibility: allowSinglePropertyAccess for gradual migration
    { code: 'obj.a?.b;', options: [{ allowSinglePropertyAccess: true }] },
    { code: 'obj.a?.b?.c;', options: [{ allowSinglePropertyAccess: true }] },

    // Mixed scenarios with allowSinglePropertyAccess
    {
      code: 'item.details?.name;',
      options: [{ maxDepth: 2, allowSinglePropertyAccess: true }],
    },
  ],

  invalid: [
    // Exceeds maxDepth (default 3)
    {
      code: 'obj?.a?.b?.c?.d;', // depth 4
      errors: [
        {
          messageId: 'tooDeep',
          data: { path: 'obj?.a?.b?.c?.d', chainDepth: 4, maxDepthOption: 3 },
        },
      ],
    },
    {
      code: 'obj.a.b.c.d;', // depth 4, also missing optional chaining
      errors: [
        {
          messageId: 'tooDeep',
          data: { path: 'obj.a.b.c.d', chainDepth: 4, maxDepthOption: 3 },
        },
      ],
    },

    // Exceeds custom maxDepth
    {
      code: 'obj?.a?.b?.c;', // depth 3
      options: [{ maxDepth: 2 }],
      errors: [
        {
          messageId: 'tooDeep',
          data: { path: 'obj?.a?.b?.c', chainDepth: 3, maxDepthOption: 2 },
        },
      ],
    },

    // Missing optional chaining from the start (NEW BEHAVIOR)
    {
      code: 'obj.a;', // Single property access without optional chaining
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'obj.a' },
        },
      ],
    },
    {
      code: 'obj.a?.b;', // First access missing optional chaining
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'obj.a' },
        },
      ],
    },
    {
      code: 'item.details?.name;', // Should be item?.details?.name
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'details', path: 'item.details' },
        },
      ],
    },
    {
      code: 'obj.a?.b?.c;', // First access missing optional chaining
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'obj.a' },
        },
      ],
    },

    // this without optional chaining
    {
      code: 'this.a;',
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'this.a' },
        },
      ],
    },
    {
      code: 'this.a?.b;',
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'this.a' },
        },
      ],
    },

    // Function calls without optional chaining
    {
      code: 'getObj().a;',
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'getObj().a' },
        },
      ],
    },
    {
      code: 'getObj().a?.b;',
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'getObj().a' },
        },
      ],
    },

    // Computed properties without optional chaining
    {
      code: 'obj[a];',
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'obj[a]' },
        },
      ],
    },
    {
      code: 'obj[a]?.[b];',
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'a', path: 'obj[a]' },
        },
      ],
    },

    // Mixed optional and non-optional (after first)
    {
      code: 'obj?.a.b;', // Second access missing optional chaining
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'b', path: 'obj?.a.b' },
        },
      ],
    },
    {
      code: 'obj?.a?.b.c;', // Third access missing optional chaining
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'c', path: 'obj?.a?.b.c' },
        },
      ],
    },

    // Edge cases with allowSinglePropertyAccess: true
    {
      code: 'obj.a.b;', // Second access still needs optional chaining
      options: [{ allowSinglePropertyAccess: true }],
      errors: [
        {
          messageId: 'missingOptionalChaining',
          data: { property: 'b', path: 'obj.a.b' },
        },
      ],
    },
  ],
});



================================================
File: test/advanced/minimize-complexflow.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester({
  languageOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
  },
});

ruleTester.run('minimize-complexflows', rules['minimize-complexflows'], {
  valid: [
    // Valid: Simple function with shallow nesting
    {
      code: `
        function getUser(id) {
          if (!id) return null; // Nesting 1
          return database.find(user => user.id === id);
        }
      `,
      options: [{ maxNestingDepth: 3, allowRecursion: false }],
    },

    // Valid: Allowed recursion when configured
    {
      code: `
        function factorial(n) {
          if (n <= 1) return 1;
          return n * factorial(n - 1);
        }
      `,
      options: [{ allowRecursion: true }],
    },

    // Valid: Within nesting limit
    {
      code: `
        function processOrder(order) {
          if (order.isValid) { // Nesting 1
            for (const item of order.items) { // Nesting 2
              if (item.inStock) { // Nesting 3
                shipItem(item);
              }
            }
          }
        }
      `,
      options: [{ maxNestingDepth: 3 }],
    },

    // Valid: Iterative approach instead of recursion
    {
      code: `
        function traverseTree(root) {
          const stack = [root];
          while (stack.length) { // Nesting 1
            const node = stack.pop();
            // process(node);
            // stack.push(...node.children);
          }
        }
      `,
    },
    // Valid: Lexical recursion allowed
    {
      code: `
          function outerFunc(n) {
            function innerFunc() {
              if (n > 0) {
                outerFunc(n - 1); // Lexical recursion
              }
            }
            innerFunc();
          }
        `,
      options: [{ allowRecursion: true }],
    },
  ],

  invalid: [
    // Invalid: Excessive nesting
    {
      code: `
        function handleRequest(req) {
          if (req.authenticated) { // Nesting 1
            if (req.hasPermission) { // Nesting 2
              if (req.isValid) { // Nesting 3
                if (req.meetsCriteria) { // Nesting 4 - Exceeds
                  return process(req);
                }
              }
            }
          }
        }
      `,
      options: [{ maxNestingDepth: 3 }],
      errors: [
        {
          messageId: 'excessiveNesting',
          data: { maxDepth: 3, currentDepth: 4 },
          type: 'IfStatement', // The node that caused the depth to exceed
          line: 6, // Line of the 4th if
        },
      ],
    },

    // Invalid: Direct recursion when not allowed
    {
      code: `
        function traverse(node) {
          // process(node);
          traverse(node.next); // Direct recursion
        }
      `,
      options: [{ allowRecursion: false }], // Default is false, but explicit for clarity
      errors: [
        {
          messageId: 'unsafeRecursion',
          data: { functionName: 'traverse' },
          type: 'CallExpression',
          line: 4,
        },
      ],
    },

    // Invalid: Lexical recursion (inner function calls outer containing function)
    {
      code: `
        function outerFunc(n) {
          function innerFunc() {
            if (n > 0) {
              outerFunc(n - 1); // Lexical recursion
            }
          }
          innerFunc();
          return n;
        }
      `,
      options: [{ allowRecursion: false }],
      errors: [
        {
          messageId: 'lexicalRecursion',
          data: {
            calledFunctionName: 'outerFunc',
            currentFunctionName: 'innerFunc',
          },
          type: 'CallExpression',
          line: 5,
        },
      ],
    },

    // Invalid: Multiple issues (Nesting and Direct Recursion)
    {
      code: `
        function complexFlow(data, condition, modified) {
          if (data) { // Nesting 1
            while (condition) { // Nesting 2
              if (checkSomething()) { // Nesting 3 - Exceeds
                return complexFlow(modified); // Direct recursion
              }
            }
          }
        }
      `,
      options: [{ maxNestingDepth: 2, allowRecursion: false }],
      errors: [
        {
          messageId: 'excessiveNesting',
          data: { maxDepth: 2, currentDepth: 3 },
          type: 'IfStatement', // The node that caused the depth to exceed
          line: 5,
        },
        {
          messageId: 'unsafeRecursion',
          data: { functionName: 'complexFlow' },
          type: 'CallExpression',
          line: 6,
        },
      ],
    },
  ],
});



================================================
File: test/advanced/minimize-deep-asynchronous-chains.test.js
================================================
const { RuleTester } = require('eslint');
const rule =
  require('../../lib/rules/advanced/plugin/minimize-deep-asynchronous-chains')
    .rules['minimize-deep-asynchronous-chains'];

const ruleTester = new RuleTester({
  languageOptions: { ecmaVersion: 2020, sourceType: 'module' },
});

ruleTester.run('minimize-deep-asynchronous-chains', rule, {
  valid: [
    // Promise Chains - Valid cases (within limits)
    {
      code: `fetch().then(res => res.json());`,
      name: 'Single .then() call',
    },
    {
      code: `fetch().then(res => res.json()).then(data => console.log(data));`,
      name: 'Two chained .then() calls',
    },
    {
      code: `fetch().then().catch().finally();`,
      name: 'Mixed .then(), .catch(), .finally() - exactly at limit',
    },
    {
      code: `promise.then(a => a).catch(err => console.error(err));`,
      name: 'Promise with .then() and .catch()',
    },
    {
      code: `new Promise(resolve => resolve()).then(x => x).finally(() => {});`,
      name: 'new Promise with chain',
    },

    // Nested Promise chains (each individual chain is within limits)
    {
      code: `
        functionA().then(() => {
          return functionB().then(res => res); // Inner chain length 1
        }).then(final => console.log(final)); // Outer chain length 2
      `,
      name: 'Nested promise chains within limits',
    },

    // Async/Await - Valid cases
    {
      code: `async function foo() { await p1; }`,
      name: 'Single await',
    },
    {
      code: `async function foo() { await p1; await p2; }`,
      name: 'Two awaits',
    },
    {
      code: `async function foo() { await p1; await p2; await p3; }`,
      name: 'Three awaits - at limit',
    },
    {
      code: `
        async function bar() {
          await step1();
          if (condition) {
            await step2(); // Still in same function scope
          }
          await step3();
        }
      `,
      name: 'Conditional await within limits',
    },
    {
      code: `
        async function outer() {
          await p1(); // 1 for outer

          async function inner() {
            await p2(); // 1 for inner (separate function)
            await p3(); // 2 for inner
            await p4(); // 3 for inner
          }

          await inner(); // 2 for outer
          await something(); // 3 for outer
        }
      `,
      name: 'Nested async functions - each within limits',
    },
    {
      code: `
        const asyncArrow = async () => {
          const a = await op1();
          const b = await op2(a);
          return await op3(b);
        };
      `,
      name: 'Async arrow function with 3 awaits',
    },

    // Custom configuration tests
    {
      code: `fetch().then().then().then().then();`,
      options: [{ maxPromiseChainLength: 4 }],
      name: 'Chain of 4 allowed with custom config',
    },
    {
      code: `async function foo() { await p1; await p2; await p3; await p4; }`,
      options: [{ maxAwaitExpressions: 4 }],
      name: '4 awaits allowed with custom config',
    },
    {
      code: `fetch().then().then();`,
      options: [{ maxPromiseChainLength: 5, maxAwaitExpressions: 1 }],
      name: 'Different limits for promises vs awaits',
    },

    // Edge cases
    {
      code: `
        // Regular function calls (not promises)
        func1().func2().func3().func4();
      `,
      name: 'Non-promise method chaining should be ignored',
    },
    {
      code: `
        async function test() {
          const promise = createPromise();
          // await in different statements
          const a = await promise;
          const b = await processA(a);
          const c = await processB(b);
        }
      `,
      name: 'Awaits with intermediate variables',
    },
  ],

  invalid: [
    // Promise Chain violations
    {
      code: `fetch().then().then().then().then();`,
      errors: [
        {
          messageId: 'tooManyThenCalls',
          data: { functionName: 'fetch()', count: 4, maxCount: 3 },
        },
      ],
      name: 'fetch() chain exceeding limit',
    },
    {
      code: `myPromise.then(a).catch(b).then(c).finally(d);`,
      errors: [
        {
          messageId: 'tooManyThenCalls',
          data: { functionName: 'myPromise', count: 4, maxCount: 3 },
        },
      ],
      name: 'Named promise chain exceeding limit',
    },
    {
      code: `api.getData().then().then().then().catch();`,
      errors: [
        {
          messageId: 'tooManyThenCalls',
          data: { functionName: 'getData()', count: 4, maxCount: 3 },
        },
      ],
      name: 'Method call promise chain exceeding limit',
    },
    {
      code: `new Promise(resolve => resolve(1)).then().then().then().finally();`,
      errors: [
        {
          messageId: 'tooManyThenCalls',
          data: { functionName: 'new Promise()', count: 4, maxCount: 3 },
        },
      ],
      name: 'new Promise chain exceeding limit',
    },

    // Async/Await violations
    {
      code: `async function foo() { await p1; await p2; await p3; await p4; }`,
      errors: [
        {
          messageId: 'tooManyAwaitExpressions',
          data: { functionName: 'foo', count: 4, maxCount: 3 },
        },
      ],
      name: 'Named async function exceeding await limit',
    },
    {
      code: `
        const bar = async () => {
          await s1;
          let x = await s2;
          if (x) { await s3; }
          await s4;
          try { await s5; } catch (e) {}
        };
      `,
      errors: [
        {
          messageId: 'tooManyAwaitExpressions',
          data: { functionName: 'bar', count: 5, maxCount: 3 },
        },
      ],
      name: 'Async arrow function with complex control flow',
    },
    {
      code: `
        async function processData(data) {
          const validated = await validateData(data);
          const transformed = await transformData(validated);
          const enriched = await enrichData(transformed);
          const saved = await saveData(enriched);
          const notification = await sendNotification(saved);
          return notification;
        }
      `,
      errors: [
        {
          messageId: 'tooManyAwaitExpressions',
          data: { functionName: 'processData', count: 5, maxCount: 3 },
        },
      ],
      name: 'Real-world async function with sequential operations',
    },

    // Custom configuration violations
    {
      code: `fetch().then().then().then();`,
      options: [{ maxPromiseChainLength: 2 }],
      errors: [
        {
          messageId: 'tooManyThenCalls',
          data: { functionName: 'fetch()', count: 3, maxCount: 2 },
        },
      ],
      name: 'Chain violation with custom limit',
    },
    {
      code: `async function foo() { await p1; await p2; await p3; }`,
      options: [{ maxAwaitExpressions: 2 }],
      errors: [
        {
          messageId: 'tooManyAwaitExpressions',
          data: { functionName: 'foo', count: 3, maxCount: 2 },
        },
      ],
      name: 'Await violation with custom limit',
    },
    {
      code: `
        async function complexFlow() {
          await step1();
          await step2();
          await step3();
          await step4();
        }
      `,
      options: [{ maxPromiseChainLength: 10, maxAwaitExpressions: 3 }],
      errors: [
        {
          messageId: 'tooManyAwaitExpressions',
          data: { functionName: 'complexFlow', count: 4, maxCount: 3 },
        },
      ],
      name: 'Only await limit violated with mixed config',
    },

    {
      code: `
        async function originalProblem(id) {
          const r1 = await op1(id);
          const r2 = await op2(r1);
          const r3 = await op3(r2);
          const r4 = await op4(r3);
          const r5 = await op5(r4);
          return r5;
        }
      `,
      errors: [
        {
          messageId: 'tooManyAwaitExpressions',
          data: { functionName: 'originalProblem', count: 5, maxCount: 3 },
        },
      ],
      name: 'Sequential async operations example',
    },
    {
      code: `
        fetch('/api/complex-data')
          .then(response => response.json())
          .then(data => firstProcessing(data))
          .then(intermediate => secondProcessing(intermediate))
          .then(finalData => displayResult(finalData));
      `,
      errors: [
        {
          messageId: 'tooManyThenCalls',
          data: { functionName: 'fetch()', count: 4, maxCount: 3 },
        },
      ],
      name: 'Complex data processing chain example',
    },

    // Mixed violations (both types in same test case)
    {
      code: `
        async function mixedViolations() {
          // This function has too many awaits
          await step1();
          await step2();
          await step3();
          await step4();

          // And also creates a long promise chain
          return fetch('/data')
            .then(res => res.json())
            .then(data => process1(data))
            .then(result => process2(result))
            .then(final => final);
        }
      `,
      errors: [
        {
          messageId: 'tooManyAwaitExpressions',
          data: { functionName: 'mixedViolations', count: 4, maxCount: 3 },
        },
        {
          messageId: 'tooManyThenCalls',
          data: { functionName: 'fetch()', count: 4, maxCount: 3 },
        },
      ],
      name: 'Function with both await and promise chain violations',
    },
  ],
});



================================================
File: test/advanced/use-runtime-assertions.test.js
================================================
const { RuleTester } = require('eslint');
const rule = require('../../lib/rules/advanced/plugin/use-runtime-assertions')
  .rules['use-runtime-assertions'];

const ruleTester = new RuleTester({
  languageOptions: { ecmaVersion: 2020, sourceType: 'module' },
});

ruleTester.run('use-runtime-assertions', rule, {
  valid: [
    // Default minAssertions: 2
    {
      code: `
        function calculate(price, rate) {
          if (typeof price !== 'number') throw new Error('Invalid price');
          if (typeof rate !== 'number') throw new Error('Invalid rate');
          return price * rate;
        }
      `,
    },
    {
      code: `
        function processData(data) {
          console.assert(data !== null, 'Data cannot be null');
          if (!data.id) {
            throw new Error('Data must have an ID');
          }
          // ...
        }
      `,
    },
    {
      code: `
        function checkUser(user) {
          if (!user) throw new Error('User undefined');
          console.assert(user.active, 'User must be active');
        }
      `,
    },
    // Custom minAssertions
    {
      code: `
        function simpleCheck(value) {
          if (value < 0) throw new Error('Value must be non-negative');
        }
      `,
      options: [{ minAssertions: 1 }],
    },
    // Custom assertion utility
    {
      code: `
        function customAssertTest(a, b) {
          myCustomAssert(typeof a === 'string', 'A must be a string');
          if (b < 0) {
              throw new Error('B must be positive');
          }
        }
      `,
      options: [
        { assertionUtilityNames: ['myCustomAssert'], minAssertions: 2 },
      ],
    },
    {
      code: `
        function nestedIfThrow(value) {
          if (value === null) {
            if (true) { // simplified nested
                throw new Error('Value is critically null'); // Assertion 1
            }
          }
          if (value < 0) {
            throw new Error('Value is negative'); // Assertion 2
          }
        }
      `, // Counts 2
    },
    {
      // Arrow function
      code: `
        const arrowAssert = (val) => {
          if (!val) throw new Error('No val');
          console.assert(val > 0, 'Val not positive');
        }
      `,
    },
    {
      // Function expression
      code: `
          const exprAssert = function(val) {
            if (!val) throw new Error('No val');
            console.assert(val > 0, 'Val not positive');
          }
        `,
    },
    {
      code: `function noBody() {}`, // Valid: empty function, ignoreEmptyFunctions=true (default), minAssertions=2 (default)
      options: [{ ignoreEmptyFunctions: true }], // Explicit for clarity, matches default
    },
    {
      code: `function noBodyMinZero() {}`,
      options: [{ minAssertions: 0, ignoreEmptyFunctions: true }],
    },
    {
      // Arrow function with implicit return
      code: `const implicit = (a) => a + 1;`,
      options: [{ minAssertions: 0 }], // Valid because minAssertions is 0
    },
    {
      // Function with only return statement - this should be valid only if minAssertions is 0
      code: `function simpleReturn(x) { return x * 2; }`,
      options: [{ minAssertions: 0 }],
    },
    {
      // Empty functions should be valid when ignoreEmptyFunctions is false but minAssertions is 0
      code: `function emptyMinZeroNoIgnore() {}`,
      options: [{ minAssertions: 0, ignoreEmptyFunctions: false }],
    },
    {
      code: `
        function readFileWithOptions_Good(options) {
          customAppAssert(
            typeof options.filePath === 'string' && options.filePath.length > 0,
            'filePath must be a non-empty string.',
          ); // Assertion 1

          if (options.encoding !== undefined) {
            customAppAssert(
              options.encoding === 'utf-8' || options.encoding === 'ascii',
              'Unsupported encoding specified.',
            ); // Assertion 2
          }
        }
      `,
      options: [
        { assertionUtilityNames: ['customAppAssert'], minAssertions: 2 },
      ],
    },
    {
      // Test case with a try-catch where assertion is in try
      code: `
        function tryCatchAssert(data) {
          try {
            if (!data) throw new Error("Data is required in try"); // Assertion 1
            console.assert(data.value > 0, "Data value must be positive"); // Assertion 2
          } catch (e) {
            // handle error
          }
        }
      `,
      // Default minAssertions: 2. Both should be found.
    },
    {
      // Test case with a switch statement
      code: `
        function switchAssert(value) {
          switch(value) {
            case 1:
              if (value !== 1) throw new Error("Impossible"); // Assertion 1
              break;
            default:
              console.assert(value > 1, "Value should be greater than 1 or not 1"); // Assertion 2
          }
        }
      `,
      // Default minAssertions: 2. Both should be found.
    },
  ],
  invalid: [
    // Default minAssertions: 2
    {
      code: `
        function calculateOne(price, rate) {
          if (typeof price !== 'number') throw new Error('Invalid price');
          // Only one assertion
          return price * rate;
        }
      `,
      errors: [
        {
          messageId: 'missingAssertions',
          data: { functionName: 'calculateOne', minCount: 2, foundCount: 1 },
        },
      ],
    },
    {
      code: `
        function noAsserts(value) {
          return value * 2;
        }
      `,
      errors: [
        {
          messageId: 'missingAssertions',
          data: { functionName: 'noAsserts', minCount: 2, foundCount: 0 },
        },
      ],
    },
    // Custom minAssertions
    {
      code: `
        function needsThree(a, b, c) {
          if (!a) throw new Error('a is required'); // 1
          console.assert(b, 'b is required');    // 2
          // Only two assertions
        }
      `,
      options: [{ minAssertions: 3 }],
      errors: [
        {
          messageId: 'missingAssertions',
          data: { functionName: 'needsThree', minCount: 3, foundCount: 2 },
        },
      ],
    },
    // Custom assertion utility name not used
    {
      code: `
        function usesWrongAssert(value) {
          console.assert(value, 'Value is present'); // Not counted
          if (value < 0) throw new Error('Negative');   // Counted (1)
        }
      `,
      options: [{ assertionUtilityNames: ['myOrgChecker'], minAssertions: 2 }],
      errors: [
        {
          messageId: 'missingAssertions',
          data: { functionName: 'usesWrongAssert', minCount: 2, foundCount: 1 },
        },
      ],
    },
    {
      // Arrow function with block body and no asserts
      code: `
        const arrowNoAssert = (val) => {
          return val;
        }
      `,
      errors: [
        {
          messageId: 'missingAssertions',
          data: { functionName: 'arrowNoAssert', minCount: 2, foundCount: 0 },
        },
      ],
    },
    {
      // Arrow function with implicit return and minAssertions > 0
      code: `const implicitFail = (a) => a + 1;`,
      options: [{ minAssertions: 1 }],
      errors: [
        {
          messageId: 'missingAssertions',
          data: { functionName: 'implicitFail', minCount: 1, foundCount: 0 },
        },
      ],
    },
    {
      code: `
        function calculateDiscount(price, discountRate) {
          // No input or output validation
          return price - (price * discountRate);
        }
      `,
      errors: [
        {
          messageId: 'missingAssertions',
          data: {
            functionName: 'calculateDiscount',
            minCount: 2,
            foundCount: 0,
          },
        },
      ],
    },
    {
      code: `
        function calculateDiscountOne(price, discountRate) {
          if (typeof price !== 'number' || price <= 0) {
            throw new Error('Price must be a positive number'); // 1
          }
          return price - (price * discountRate);
        }
      `,
      errors: [
        {
          messageId: 'missingAssertions',
          data: {
            functionName: 'calculateDiscountOne',
            minCount: 2,
            foundCount: 1,
          },
        },
      ],
    },
    {
      code: `function emptyFail() {}`,
      options: [{ ignoreEmptyFunctions: false, minAssertions: 2 }],
      errors: [
        {
          messageId: 'missingAssertions',
          data: { functionName: 'emptyFail', minCount: 2, foundCount: 0 },
        },
      ],
    },
    {
      code: `function emptyFailOneAssert() {}`,
      options: [{ ignoreEmptyFunctions: false, minAssertions: 1 }],
      errors: [
        {
          messageId: 'missingAssertions',
          data: {
            functionName: 'emptyFailOneAssert',
            minCount: 1,
            foundCount: 0,
          },
        },
      ],
    },
    {
      // Test with a For loop that doesn't contain assertions
      code: `
        function loopNoAssert(arr) {
          for (let i = 0; i < arr.length; i++) {
            console.log(arr[i]);
          }
        }
      `,
      options: [{ minAssertions: 1 }],
      errors: [
        {
          messageId: 'missingAssertions',
          data: { functionName: 'loopNoAssert', minCount: 1, foundCount: 0 },
        },
      ],
    },
  ],
});



================================================
File: test/angular/angular-filenaming.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;
const tsParser = require('@typescript-eslint/parser');

const ruleTester = new RuleTester({
  languageOptions: {
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run('angular-filenaming', rules['angular-filenaming'], {
  valid: [
    // Component - kebab-case, Service - camelCase, Module - PascalCase
    {
      code: 'export class AppComponent {}',
      filename: 'app-component.component.ts',
      options: [
        { component: 'kebab-case', service: 'camelCase', module: 'PascalCase' },
      ],
    },
    {
      code: 'export class AppService {}',
      filename: 'appService.service.ts',
      options: [
        { component: 'kebab-case', service: 'camelCase', module: 'PascalCase' },
      ],
    },
    {
      code: 'export class AppModule {}',
      filename: 'AppModule.module.ts',
      options: [
        { component: 'kebab-case', service: 'camelCase', module: 'PascalCase' },
      ],
    },

    // Component - PascalCase, Service - PascalCase, Module - PascalCase
    {
      code: 'export class AppComponent {}',
      filename: 'AppComponent.component.ts',
      options: [
        {
          component: 'PascalCase',
          service: 'PascalCase',
          module: 'PascalCase',
        },
      ],
    },
    {
      code: 'export class AppService {}',
      filename: 'AppService.service.ts',
      options: [
        {
          component: 'PascalCase',
          service: 'PascalCase',
          module: 'PascalCase',
        },
      ],
    },
    {
      code: 'export class AppModule {}',
      filename: 'AppModule.module.ts',
      options: [
        {
          component: 'PascalCase',
          service: 'PascalCase',
          module: 'PascalCase',
        },
      ],
    },
  ],

  invalid: [
    // Invalid kebab-case for component files
    {
      code: 'export class AppComponent {}',
      filename: 'AppComponent.component.ts',
      options: [{ component: 'kebab-case' }],
      errors: [
        {
          message:
            'File "AppComponent.component.ts" does not follow the kebab-case naming convention.',
        },
      ],
    },
    // Invalid camelCase for service files
    {
      code: 'export class AppService {}',
      filename: 'AppService.service.ts',
      options: [{ service: 'camelCase' }],
      errors: [
        {
          message:
            'File "AppService.service.ts" does not follow the camelCase naming convention.',
        },
      ],
    },
    // Invalid PascalCase for module files
    {
      code: 'export class AppModule {}',
      filename: 'appModule.module.ts',
      options: [{ module: 'PascalCase' }],
      errors: [
        {
          message:
            'File "appModule.module.ts" does not follow the PascalCase naming convention.',
        },
      ],
    },
  ],
});



================================================
File: test/angular/angular-limit-input.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;
const tsParser = require('@typescript-eslint/parser');

const ruleTester = new RuleTester({
  languageOptions: {
    parser: tsParser,
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run('angular-limit-input', rules['angular-limit-input'], {
  valid: [
    // Component with allowed number of @Input and @Output
    {
      code: `
        import { Component, Input, Output } from '@angular/core';
        @Component({})
        class AppComponent {
          @Input() input1: string;
          @Input() input2: string;
          @Output() output1 = new EventEmitter();
        }
      `,
      options: [{ max: 5 }],
    },
    // Component with no @Input or @Output properties
    {
      code: `
        import { Component } from '@angular/core';
        @Component({})
        class AppComponent {
        }
      `,
      options: [{ max: 3 }],
    },
  ],
  invalid: [
    // Component with too many @Input and @Output
    {
      code: `
        import { Component, Input, Output } from '@angular/core';
        @Component({})
        class AppComponent {
          @Input() input1: string;
          @Input() input2: string;
          @Input() input3: string;
          @Input() input4: string;
          @Input() input5: string;
          @Output() output1 = new EventEmitter();
        }
      `,
      options: [{ max: 5 }],
      errors: [
        {
          message:
            'Component "AppComponent" has too many @Input() or @Output() properties (6), limit is 5.',
        },
      ],
    },
  ],
});



================================================
File: test/angular/angular-no-direct-dom-manipulation.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;
const tsParser = require('@typescript-eslint/parser');

const ruleTester = new RuleTester({
  languageOptions: {
    parser: tsParser,
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run(
  'angular-no-direct-dom-manipulation',
  rules['angular-no-direct-dom-manipulation'],
  {
    valid: [
      // Valid usage of Renderer2 for DOM manipulation
      {
        code: `
        import { Renderer2 } from '@angular/core';
        class MyComponent {
          constructor(private renderer: Renderer2) {}

          ngAfterViewInit() {
            this.renderer.setStyle(this.element, 'color', 'red');
          }
        }
      `,
      },
    ],
    invalid: [
      // Invalid direct DOM manipulation with document.getElementById
      {
        code: `
        class MyComponent {
          ngAfterViewInit() {
            const el = document.getElementById('my-element');
          }
        }
      `,
        errors: [
          {
            message:
              'Avoid direct DOM manipulation with "document.getElementById". Use Angular\'s Renderer2 for DOM interactions.',
          },
        ],
      },
    ],
  }
);



================================================
File: test/angular/angular-no-forbidden-services.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;
const tsParser = require('@typescript-eslint/parser');

const ruleTester = new RuleTester({
  languageOptions: {
    parser: tsParser,
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run(
  'angular-no-forbidden-services',
  rules['angular-no-forbidden-services'],
  {
    valid: [
      {
        code: `
          import { Component } from '@angular/core';
          import { SomeService } from './some.service';
  
          @Component({
            selector: 'app-my-component',
            template: '<div></div>',
          })
          class MyComponent {
            constructor(private someService: SomeService) {}
          }
        `,
        options: [{ forbiddenServices: ['HttpClient'] }],
      },
    ],
    invalid: [
      {
        code: `
          import { Component, HttpClient } from '@angular/core';
  
          @Component({
            selector: 'app-my-component',
            template: '<div></div>',
          })
          class MyComponent {
            constructor(private httpClient: HttpClient) {}
          }
        `,
        errors: [
          {
            message:
              "The service 'HttpClient' should not be injected directly into components. Consider moving it to a dedicated service or resolver.",
          },
        ],
        options: [{ forbiddenServices: ['HttpClient'] }],
      },
    ],
  }
);



================================================
File: test/angular/angular-no-unused-inputs.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;
const tsParser = require('@typescript-eslint/parser');

const ruleTester = new RuleTester({
  languageOptions: {
    parser: tsParser,
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run('angular-no-unused-inputs', rules['angular-no-unused-inputs'], {
  valid: [
    {
      code: `
        import { Input } from '@angular/core';
        class MyComponent {
          @Input() someInput: string;

          ngOnInit() {
            console.log(this.someInput);
          }
        }
      `,
    },
  ],
  invalid: [
    {
      code: `
        import { Input } from '@angular/core';
        class MyComponent {
          @Input() unusedInput: string;

          ngOnInit() {
            console.log('This does nothing with the input');
          }
        }
      `,
      errors: [
        {
          message:
            'The @Input() property "unusedInput" is declared but never used in the component.',
        },
      ],
    },
  ],
});



================================================
File: test/express/http-status-code.test.js
================================================
const { RuleTester } = require('eslint');
// const plugin = require('../../index'); // Assuming top-level index exports all rules
// const rule = plugin.rules['http-status-code'];
const rule =
  require('../../lib/rules/node/express/open-api-spec/plugin/http-status-code')
    .rules['http-status-code'];

const ruleTester = new RuleTester({
  languageOptions: {
    ecmaVersion: 2020,
    sourceType: 'module',
    globals: {
      // Common Express globals
      app: 'writable',
      router: 'writable',
      require: 'readonly',
      module: 'readonly',
      process: 'readonly',
      console: 'readonly',
    },
  },
});

const defaultErrorMessage = (method, expected, actual, resName = 'res') =>
  `Expected ${resName}.status(${expected.join(' or ')}) for ${method} request, but found ${resName}.status(${actual}).`;

const sendStatusErrorMessage = (method, expected, actual, resName = 'res') =>
  `Expected ${resName}.sendStatus(${expected.join(' or ')}) for ${method} request, but found ${resName}.sendStatus(${actual}).`;

ruleTester.run('http-status-code', rule, {
  valid: [
    // Default GET
    "app.get('/users', (req, res) => { res.status(200).send('Ok'); });",
    "router.get('/items', (req, res) => { res.status(200).json([]); });",
    // Default POST
    "app.post('/users', (req, res) => { res.status(201).send('Created'); });",
    // Default DELETE
    "app.delete('/users/:id', (req, res) => { res.status(204).end(); });",
    "app.delete('/users/:id', (req, res) => { res.status(200).send('Deleted OK'); });",
    // Default PUT
    "app.put('/users/:id', (req, res) => { res.status(200).send('Updated'); });",
    "app.put('/users/:id', (req, res) => { res.status(204).send(); });",
    // Default PATCH
    "app.patch('/users/:id', (req, res) => { res.status(200).json({partial: true}); });",
    "app.patch('/users/:id', (req, res) => { res.status(204).end(); });",
    // res.sendStatus
    "app.get('/status', (req, res) => { res.sendStatus(200); });",
    "app.post('/status', (req, res) => { res.sendStatus(201); });",
    // Conditional status
    "app.get('/conditional', (req, res) => { if (req.query.err) { res.status(500).send('Error'); } else { res.status(200).send('OK'); } });",
    // No explicit status (Express defaults to 200, rule doesn't check this case currently)
    "app.get('/implicit', (req, res) => { res.send('Ok by default'); });",
    // Custom response object name
    {
      code: "app.get('/custom', (req, reply) => { reply.status(200).send('Ok'); });",
      options: [{ responseObjectName: 'reply' }],
    },
    // Custom status codes
    {
      code: "app.post('/custom-post', (req, res) => { res.status(200).send('Ok'); });",
      options: [{ validStatusCodesByMethod: { POST: [200, 202] } }],
    },
    // Chained .status().status().send() - last one should count
    "app.get('/chained-status', (req, res) => { res.status(500).status(200).send('Final is 200'); });",
    // Handler as a separate function
    `
      function getUserHandler(req, res) { res.status(200).json({}); }
      app.get('/user-handler', getUserHandler);
    `,
    // Methods not in default config (e.g. all, use) - should not error if no res.status()
    "app.all('/all-path', (req, res, next) => { next(); });",
    "app.use('/middleware', (req, res, next) => { res.header('X-Custom', 'true'); next(); });",
    // Method not in default config, but with res.status() - should not error IF that method has no default config
    // To test this properly, you'd need a method NOT in DEFAULT_STATUS_CODES_BY_METHOD
    // e.g., if 'TRACE' was a known express method but not in defaults
    // "app.trace('/trace-path', (req, res) => { res.status(200).send(); });", // Assuming TRACE has no default expectations
  ],
  invalid: [
    {
      code: "app.get('/users', (req, res) => { res.status(201).send('Wrong'); });",
      errors: [{ message: defaultErrorMessage('GET', [200], 201) }],
    },
    {
      code: "router.post('/items', (req, res) => { res.status(200).json({}); });",
      errors: [{ message: defaultErrorMessage('POST', [201], 200) }],
    },
    {
      code: "app.delete('/users/:id', (req, res) => { res.status(201).end(); });",
      errors: [{ message: defaultErrorMessage('DELETE', [200, 204], 201) }],
    },
    {
      code: "app.put('/users/:id', (req, res) => { res.status(201).send(); });",
      errors: [{ message: defaultErrorMessage('PUT', [200, 204], 201) }],
    },
    {
      code: "app.patch('/users/:id', (req, res) => { res.status(201).json({}); });",
      errors: [{ message: defaultErrorMessage('PATCH', [200, 204], 201) }],
    },
    // res.sendStatus
    {
      code: "app.get('/status-err', (req, res) => { res.sendStatus(201); });", // Changed 404 to 201
      errors: [{ message: sendStatusErrorMessage('GET', [200], 201) }], // Error message reflects 201
    },
    {
      code: "app.post('/status-err-post', (req, res) => { res.sendStatus(200); });",
      errors: [{ message: sendStatusErrorMessage('POST', [201], 200) }],
    },
    // Custom response object name
    {
      code: "app.get('/custom-err', (req, reply) => { reply.status(204).send('Err'); });", // Changed 400 to 204
      options: [{ responseObjectName: 'reply' }],
      errors: [{ message: defaultErrorMessage('GET', [200], 204, 'reply') }], // Error message reflects 204
    },
    // Custom status codes, but still wrong
    {
      code: "app.post('/custom-post-err', (req, res) => { res.status(200).send('Bad'); });", // Changed 400 to 200
      options: [{ validStatusCodesByMethod: { POST: [202] } }],
      errors: [{ message: defaultErrorMessage('POST', [202], 200) }], // Error message reflects 200
    },
    // Chained status, last one is wrong
    {
      code: "app.get('/chained-status-err', (req, res) => { res.status(200).status(201).send('Forbidden'); });", // 201 is not 200 for GET
      errors: [{ message: defaultErrorMessage('GET', [200], 201) }],
    },
  ],
});



================================================
File: test/general/class-pascalcase.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('class-pascalcase', rules['class-pascalcase'], {
  valid: [{ code: 'class MyClass {}' }, { code: 'class PascalCaseName {}' }],
  invalid: [
    {
      code: 'class myClass {}',
      errors: [{ message: 'Class name "myClass" must be in PascalCase.' }],
    },
    {
      code: 'class another_class {}',
      errors: [
        { message: 'Class name "another_class" must be in PascalCase.' },
      ],
    },
  ],
});



================================================
File: test/general/consistent-return.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('consistent-return', rules['consistent-return'], {
  valid: [
    {
      code: 'function validFunction(a) { return a; }',
    },
    {
      code: 'const validArrowFunction = (a) => { return a; };',
    },
    {
      code: 'function validFunctionWithMultipleReturns(a) { if (a) return a; else return; }',
    },
    {
      code: 'function validFunctionWithReturnInConditional(a) { if (a) return a; }',
    },
  ],

  invalid: [
    {
      code: 'function invalidFunction(a) { const b = a + 1; }',
      errors: [
        { messageId: 'missingReturn', data: { name: 'invalidFunction' } },
      ],
    },
    {
      code: 'const invalidArrowFunction = (a) => { const b = a + 1; };',
      errors: [{ messageId: 'missingReturn', data: { name: 'function' } }],
    },
    {
      code: 'function anotherInvalidFunction(a) { let b = a + 1; if (b > 10) { b += 10; } }',
      errors: [
        {
          messageId: 'missingReturn',
          data: { name: 'anotherInvalidFunction' },
        },
      ],
    },
  ],
});



================================================
File: test/general/file-camelcase.test.js
================================================
const { RuleTester } = require('eslint');
const path = require('path');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('file-camelcase', rules['file-camelcase'], {
  valid: [
    {
      filename: path.join(__dirname, 'validFileName.js'),
      code: 'console.log("Valid file name");',
    },
    {
      filename: path.join(__dirname, 'short.js'),
      code: 'console.log("Short file name");',
    },
    {
      filename: path.join(__dirname, 'someDir', 'validFileName.ts'),
      code: 'console.log("Valid file name in directory");',
    },
    {
      filename: path.join(__dirname, 'shortdir', 'validFileName.json'),
      code: 'console.log("Valid file name with short directory");',
    },
    {
      filename: path.join(__dirname, 'validDirName', 'file.js'),
      code: 'console.log("Valid directory name");',
    },
  ],

  invalid: [
    {
      filename: path.join(__dirname, 'InvalidFileName.js'),
      code: 'console.log("Invalid file name");',
      errors: [
        { messageId: 'invalidFileName', data: { name: 'InvalidFileName.js' } },
      ],
    },
    {
      filename: path.join(__dirname, 'INVALID.js'),
      code: 'console.log("Invalid short file name");',
      errors: [{ messageId: 'invalidFileName', data: { name: 'INVALID.js' } }],
    },
  ],
});



================================================
File: test/general/file-kebabcase.test.js
================================================
const { RuleTester } = require('eslint');
const path = require('path');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('file-kebabcase', rules['file-kebabcase'], {
  valid: [
    {
      filename: path.join(__dirname, 'valid-file-name.js'),
      code: 'console.log("Valid file name");',
    },
    {
      filename: path.join(__dirname, 'short.js'),
      code: 'console.log("Short file name");',
    },
    {
      filename: path.join(__dirname, 'some-dir', 'valid-file-name.ts'),
      code: 'console.log("Valid file name in directory");',
    },
    {
      filename: path.join(__dirname, 'shortdir', 'valid-file-name.json'),
      code: 'console.log("Valid file name with short directory");',
    },
  ],

  invalid: [
    {
      filename: path.join(__dirname, 'InvalidFileName.js'),
      code: 'console.log("Invalid file name");',
      errors: [
        { messageId: 'invalidFileName', data: { name: 'InvalidFileName.js' } },
      ],
    },
    {
      filename: path.join(__dirname, 'INVALID.js'),
      code: 'console.log("Invalid short file name");',
      errors: [{ messageId: 'invalidFileName', data: { name: 'INVALID.js' } }],
    },
  ],
});



================================================
File: test/general/file-lowercase.test.js
================================================
const { RuleTester } = require('eslint');
const path = require('path');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('file-lowercase', rules['file-lowercase'], {
  valid: [
    {
      filename: path.join(__dirname, 'validfile.js'),
      code: 'console.log("Valid lowercase filename");',
    },
    {
      filename: path.join(__dirname, 'short.js'),
      code: 'console.log("Valid lowercase filename");',
    },
    {
      filename: path.join(__dirname, 'some-dir', 'validfile.js'),
      code: 'console.log("Valid lowercase filename");',
    },
    {
      filename: path.join(__dirname, 'valid-file-name.js'),
      code: 'console.log("Valid lowercase filename with hyphens");',
    },
  ],

  invalid: [
    {
      filename: path.join(__dirname, 'InvalidFileName.js'),
      code: 'console.log("Invalid filename");',
      errors: [
        { messageId: 'invalidFileName', data: { name: 'InvalidFileName.js' } },
      ],
    },
    {
      filename: path.join(__dirname, 'INVALID.js'),
      code: 'console.log("Invalid filename");',
      errors: [{ messageId: 'invalidFileName', data: { name: 'INVALID.js' } }],
    },
    {
      filename: path.join(__dirname, 'Invalid-File-Name.js'),
      code: 'console.log("Invalid filename");',
      errors: [
        {
          messageId: 'invalidFileName',
          data: { name: 'Invalid-File-Name.js' },
        },
      ],
    },
  ],
});



================================================
File: test/general/file-pascalcase.test.js
================================================
const { RuleTester } = require('eslint');
const path = require('path');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('file-pascalcase', rules['file-pascalcase'], {
  valid: [
    {
      filename: path.join(__dirname, 'ValidFileName.js'),
      code: 'console.log("Valid file name");',
    },
    {
      filename: path.join(__dirname, 'Short.js'),
      code: 'console.log("Short file name");',
    },
    {
      filename: path.join(__dirname, 'SomeDir', 'ValidFileName.ts'),
      code: 'console.log("Valid file name in directory");',
    },
    {
      filename: path.join(__dirname, 'ShortDir', 'ValidFileName.json'),
      code: 'console.log("Valid file name with short directory");',
    },
  ],

  invalid: [
    {
      filename: path.join(__dirname, 'invalidFileName.js'),
      code: 'console.log("Invalid file name");',
      errors: [
        { messageId: 'invalidFileName', data: { name: 'invalidFileName.js' } },
      ],
    },
    {
      filename: path.join(__dirname, 'invalid.js'),
      code: 'console.log("Invalid short file name");',
      errors: [{ messageId: 'invalidFileName', data: { name: 'invalid.js' } }],
    },
  ],
});



================================================
File: test/general/folder-camelcase.test.js
================================================
const { RuleTester } = require('eslint');
const path = require('path');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('folder-camelcase', rules['folder-camelcase'], {
  valid: [
    {
      filename: path.join(__dirname, 'validDirName', 'file.js'),
      code: 'console.log("Valid directory name");',
    },
    {
      filename: path.join(__dirname, 'shortdir', 'file.js'),
      code: 'console.log("Short directory name");',
    },
  ],

  invalid: [
    {
      filename: path.join(__dirname, 'Invalid-Dir-Name', 'file.js'),
      code: 'console.log("Invalid directory name");',
      errors: [
        { messageId: 'invalidFolderName', data: { name: 'Invalid-Dir-Name' } },
      ],
    },
    {
      filename: path.join(__dirname, 'invalid-dir-name', 'file.js'),
      code: 'console.log("Invalid directory name");',
      errors: [
        { messageId: 'invalidFolderName', data: { name: 'invalid-dir-name' } },
      ],
    },
  ],
});



================================================
File: test/general/folder-kebabcase.test.js
================================================
const { RuleTester } = require('eslint');
const path = require('path');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('folder-kebabcase', rules['folder-kebabcase'], {
  valid: [
    {
      filename: path.join(__dirname, 'valid-dir-name', 'file.js'),
      code: 'console.log("Valid directory name");',
    },
    {
      filename: path.join(__dirname, 'shortdir', 'file.js'),
      code: 'console.log("Short directory name");',
    },
  ],

  invalid: [
    {
      filename: path.join(__dirname, 'Invalid-Dir-Name', 'file.js'),
      code: 'console.log("Invalid directory name");',
      errors: [
        { messageId: 'invalidFolderName', data: { name: 'Invalid-Dir-Name' } },
      ],
    },
    {
      filename: path.join(__dirname, 'invalid_dir_name', 'file.js'),
      code: 'console.log("Invalid directory name");',
      errors: [
        { messageId: 'invalidFolderName', data: { name: 'invalid_dir_name' } },
      ],
    },
  ],
});



================================================
File: test/general/folder-lowercase.test.js
================================================
const { RuleTester } = require('eslint');
const path = require('path');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('folder-lowercase', rules['folder-lowercase'], {
  valid: [
    {
      filename: path.join(__dirname, 'validfolder', 'validfile.js'),
      code: 'console.log("Valid lowercase folder and file names");',
    },
    {
      filename: path.join(__dirname, 'shortfolder', 'shortfile.js'),
      code: 'console.log("Valid lowercase folder and file names");',
    },
    {
      filename: path.join(__dirname, 'anotherfolder', 'validfile.js'),
      code: 'console.log("Valid lowercase folder and file names");',
    },
  ],

  invalid: [
    {
      filename: path.join(__dirname, 'InvalidFolder', 'validfile.js'),
      code: 'console.log("Invalid folder name");',
      errors: [
        { messageId: 'invalidFolderName', data: { name: 'InvalidFolder' } },
      ],
    },
    {
      filename: path.join(__dirname, 'AnotherInvalidFolder', 'file.js'),
      code: 'console.log("Invalid folder name");',
      errors: [
        {
          messageId: 'invalidFolderName',
          data: { name: 'AnotherInvalidFolder' },
        },
      ],
    },
  ],
});



================================================
File: test/general/folder-pascalcase.test.js
================================================
const { RuleTester } = require('eslint');
const path = require('path');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('folder-pascalcase', rules['folder-pascalcase'], {
  valid: [
    {
      filename: path.join(__dirname, 'ValidDirName', 'File.js'),
      code: 'console.log("Valid directory name");',
    },
    {
      filename: path.join(__dirname, 'ShortDir', 'file.js'),
      code: 'console.log("Short directory name");',
    },
  ],

  invalid: [
    {
      filename: path.join(__dirname, 'invalid-dir-name', 'ValidFileName.js'),
      code: 'console.log("Valid file name in invalid directory");',
      errors: [
        { messageId: 'invalidFolderName', data: { name: 'invalid-dir-name' } },
      ],
    },
    {
      filename: path.join(__dirname, 'invalidDirName', 'file.js'),
      code: 'console.log("Invalid directory name");',
      errors: [
        { messageId: 'invalidFolderName', data: { name: 'invalidDirName' } },
      ],
    },
  ],
});



================================================
File: test/general/function-camelcase.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('function-camelcase', rules['function-camelcase'], {
  valid: [
    { code: 'function myFunction() {}' },
    { code: 'function anotherFunction123() {}' },
    { code: 'const myFunction = function() {};' },
    { code: 'const anotherFunction123 = function() {};' },
    { code: 'const myFunction = () => {};' },
    { code: 'const anotherFunction123 = () => {};' },
  ],
  invalid: [
    {
      code: 'function MyFunction() {}',
      errors: [
        { message: "Function name 'MyFunction' should be in camelCase." },
      ],
    },
    {
      code: 'function another_class() {}',
      errors: [
        { message: "Function name 'another_class' should be in camelCase." },
      ],
    },
    {
      code: 'const MyFunction = function() {};',
      errors: [
        { message: "Function name 'MyFunction' should be in camelCase." },
      ],
    },
    {
      code: 'const another_class = function() {};',
      errors: [
        { message: "Function name 'another_class' should be in camelCase." },
      ],
    },
    {
      code: 'const MyFunction = () => {};',
      errors: [
        { message: "Function name 'MyFunction' should be in camelCase." },
      ],
    },
    {
      code: 'const another_class = () => {};',
      errors: [
        { message: "Function name 'another_class' should be in camelCase." },
      ],
    },
  ],
});



================================================
File: test/general/function-descriptive.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('function-descriptive', rules['function-descriptive'], {
  valid: [
    { code: 'function fetchData() {}' },
    { code: 'const processOrder = function() {};' },
    { code: 'const calculateTotal = () => {};' },
    { code: 'function getUserInfo() {}' },
    { code: 'function sendEmail() {}' },
  ],
  invalid: [
    {
      code: 'function Data() {}',
      errors: [
        {
          message:
            "Function name 'Data' should start with a verb and be descriptive.",
        },
      ],
    },
    {
      code: 'function User() {}',
      errors: [
        {
          message:
            "Function name 'User' should start with a verb and be descriptive.",
        },
      ],
    },
  ],
});



================================================
File: test/general/function-pascalcase.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('function-pascalcase', rules['function-pascalcase'], {
  valid: [
    { code: 'function MyFunction() {}' },
    { code: 'function AnotherFunction123() {}' },
    { code: 'const MyFunction = function() {};' },
    { code: 'const AnotherFunction123 = function() {};' },
    { code: 'const MyFunction = () => {};' },
    { code: 'const AnotherFunction123 = () => {};' },
  ],
  invalid: [
    {
      code: 'function myFunction() {}',
      errors: [
        { message: "Function name 'myFunction' should be in PascalCase." },
      ],
    },
    {
      code: 'function another_function() {}',
      errors: [
        {
          message: "Function name 'another_function' should be in PascalCase.",
        },
      ],
    },
    {
      code: 'const myFunction = function() {};',
      errors: [
        { message: "Function name 'myFunction' should be in PascalCase." },
      ],
    },
    {
      code: 'const another_function = function() {};',
      errors: [
        {
          message: "Function name 'another_function' should be in PascalCase.",
        },
      ],
    },
    {
      code: 'const myFunction = () => {};',
      errors: [
        { message: "Function name 'myFunction' should be in PascalCase." },
      ],
    },
    {
      code: 'const another_function = () => {};',
      errors: [
        {
          message: "Function name 'another_function' should be in PascalCase.",
        },
      ],
    },
  ],
});



================================================
File: test/general/max-function-params.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('max-function-params', rules['max-function-params'], {
  valid: [
    {
      code: 'function validFunction(a, b) {}',
      options: [{ max: 2 }],
    },
    {
      code: 'function validFunction(a) {}',
      options: [{ max: 3 }],
    },
    {
      code: 'const validArrowFunction = (a, b) => {};',
      options: [{ max: 2 }],
    },
    {
      code: 'const validArrowFunction = (a) => {};',
      options: [{ max: 3 }],
    },
    {
      code: 'function validFunction(a, b, c) {}',
      options: [{ max: 3 }],
    },
  ],

  invalid: [
    {
      code: 'function invalidFunction(a, b, c, d) {}',
      options: [{ max: 2 }],
      errors: [
        {
          messageId: 'tooManyParameters',
          data: { name: 'invalidFunction', count: 4, max: 2 },
        },
      ],
    },
    {
      code: 'const invalidArrowFunction = (a, b, c, d) => {};',
      options: [{ max: 2 }],
      errors: [
        {
          messageId: 'tooManyParameters',
          data: { name: 'Anonymous function', count: 4, max: 2 },
        },
      ],
    },
    {
      code: 'function anotherInvalidFunction(a, b, c, d, e) {}',
      options: [{ max: 4 }],
      errors: [
        {
          messageId: 'tooManyParameters',
          data: { name: 'anotherInvalidFunction', count: 5, max: 4 },
        },
      ],
    },
  ],
});



================================================
File: test/general/max-lines-per-file.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('max-lines-per-file', rules['max-lines-per-file'], {
  valid: [
    {
      filename: 'short-file.js',
      code: Array(5).fill('uniqueVar1 = 1;').join('\n'), // 5 lines, valid
    },
    {
      filename: 'another-valid-file.js',
      code: Array(10).fill('uniqueVar2 = 2;').join('\n'), // 10 lines, valid
    },
  ],
  invalid: [
    {
      filename: 'long-file.js',
      code: Array(15).fill('uniqueinvalidVar1 = 3;').join('\n'), // 15 lines, invalid
      options: [{ max: 10 }], // Set max to 10 lines
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'long-file.js',
            max: 10,
            lines: 15,
          },
        },
      ],
    },
    {
      filename: 'another-long-file.js',
      code: Array(20).fill(' uniqueinvalidVar2 = 4;').join('\n'), // 20 lines, invalid
      options: [{ max: 15 }], // Set max to 15 lines
      errors: [
        {
          messageId: 'tooManyLines',
          data: {
            name: 'another-long-file.js',
            max: 15,
            lines: 20,
          },
        },
      ],
    },
  ],
});



================================================
File: test/general/max-lines-per-function.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('max-lines-per-function', rules['max-lines-per-function'], {
  valid: [
    {
      code: `
        function shortFunction() {
          const a = 1;
          const b = 2;
          return a + b;
        }
      `,
      options: [{ max: 5 }],
    },
    {
      code: `
        const arrowFunction = () => {
          // This is a short arrow function
          return 'Hello, World!';
        };
      `,
      options: [{ max: 4 }],
    },
    {
      code: `
        function exactlyAtLimit() {
          const line1 = 1;
          const line2 = 2;
          const line3 = 3;
          return line1 + line2 + line3;
        }
      `,
      options: [{ max: 6 }],
    },
    {
      code: `
        // Should ignore single-line functions
        const singleLine = () => 'Hello';
      `,
      options: [{ max: 1 }],
    },
  ],
  invalid: [
    {
      code: `
        function tooLongFunction() {
          const a = 1;
          const b = 2;
          const c = 3;
          return a + b + c;
        }
      `,
      options: [{ max: 5 }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: { name: 'tooLongFunction', max: 5, lines: 6 },
        },
      ],
    },
    {
      code: `
        const longArrowFunction = () => {
          const line1 = 'This is line 1';
          const line2 = 'This is line 2';
          const line3 = 'This is line 3';
          const line4 = 'This is line 4';
          return line1 + line2 + line3 + line4;
        };
      `,
      options: [{ max: 6 }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: { name: 'Anonymous function', max: 6, lines: 7 },
        },
      ],
    },
    {
      code: `
        function barelyOverLimit() {
          const line1 = 1;
          const line2 = 2;
          const line3 = 3;
          const line4 = 4;
          return line1 + line2 + line3 + line4;
        }
      `,
      options: [{ max: 6 }],
      errors: [
        {
          messageId: 'tooManyLines',
          data: { name: 'barelyOverLimit', max: 6, lines: 7 },
        },
      ],
    },
  ],
});



================================================
File: test/general/no-single-character-vars.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('no-single-character-vars', rules['no-single-character-vars'], {
  valid: [
    {
      code: 'const validName = 1;',
    },
    {
      code: 'let anotherValidName = 2;',
    },
    {
      code: 'var validVariable = 3;',
    },
  ],

  invalid: [
    {
      code: 'const x = 1;',
      errors: [{ messageId: 'singleCharVar', data: { name: 'x' } }],
    },
    {
      code: 'let a = 2;',
      errors: [{ messageId: 'singleCharVar', data: { name: 'a' } }],
    },
    {
      code: 'var b = 3;',
      errors: [{ messageId: 'singleCharVar', data: { name: 'b' } }],
    },
  ],
});



================================================
File: test/general/vars-camelcase.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('vars-camelcase', rules['vars-camelcase'], {
  valid: [
    // Valid variable declarations
    { code: 'var myVariable = 1;' },
    { code: 'let anotherVariable = 2;' },
    { code: 'const someValue = 3;' },
    { code: 'var validName = "text";' },
    { code: 'let alsoValid = [1, 2, 3];' },
    { code: 'const myArray = [];' },
    { code: 'const camelCaseName = "example";' },
  ],
  invalid: [
    // Invalid variable declarations
    {
      code: 'var InvalidName = 1;',
      errors: [{ message: "Variable 'InvalidName' should be in camelCase." }],
    },
    {
      code: 'let Another_Variable = 2;',
      errors: [
        { message: "Variable 'Another_Variable' should be in camelCase." },
      ],
    },
    {
      code: 'const NonCamelCase = 3;',
      errors: [{ message: "Variable 'NonCamelCase' should be in camelCase." }],
    },
    {
      code: 'var invalid_name = "text";',
      errors: [{ message: "Variable 'invalid_name' should be in camelCase." }],
    },
    {
      code: 'const _nonCamelCase = 4;',
      errors: [{ message: "Variable '_nonCamelCase' should be in camelCase." }],
    },
  ],
});



================================================
File: test/general/vars-descriptive.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('vars-descriptive', rules['vars-descriptive'], {
  valid: [
    // Valid variable declarations (starting with verbs)
    { code: 'let calculateTotal = 100;' },
    { code: 'const fetchData = [];' },
    { code: 'var updateUser = "John";' },
    { code: 'let processOrder = 1;' },
    { code: 'const generateReport = {};' },
    { code: 'var checkStatus = true;' },
    { code: 'let handleError = function() {};' },
    { code: 'const logMessage = "Log";' },
  ],
  invalid: [
    // Invalid variable declarations (not starting with verbs)
    {
      code: 'const userInfo = [];',
      errors: [
        {
          message:
            "Variable name 'userInfo' should start with a verb and be descriptive.",
        },
      ],
    },

    {
      code: 'const statusFlag = {};',
      errors: [
        {
          message:
            "Variable name 'statusFlag' should start with a verb and be descriptive.",
        },
      ],
    },
    {
      code: 'var errorHandler = true;',
      errors: [
        {
          message:
            "Variable name 'errorHandler' should start with a verb and be descriptive.",
        },
      ],
    },
  ],
});



================================================
File: test/general/vars-lowercase.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('vars-lowercase', rules['vars-lowercase'], {
  valid: [
    {
      code: 'var lowercase = 3;',
    },
  ],

  invalid: [
    {
      code: 'const InvalidName = 1;',
      errors: [{ messageId: 'notLowerCase', data: { name: 'InvalidName' } }],
    },
    {
      code: 'let AnotherInvalidName = 2;',
      errors: [
        { messageId: 'notLowerCase', data: { name: 'AnotherInvalidName' } },
      ],
    },
    {
      code: 'var MIXED_CASE = 3;',
      errors: [{ messageId: 'notLowerCase', data: { name: 'MIXED_CASE' } }],
    },
  ],
});



================================================
File: test/general/vars-pascalcase.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('vars-pascalcase', rules['vars-pascalcase'], {
  valid: [
    // Add cases that should not trigger the rule
    'const MyVariable = 10;',
    'let AnotherVariable = 20;',
    'var SomeVariable = "test";',
  ],
  invalid: [
    {
      code: 'const myVariable = 10;',
      output: 'const MyVariable = 10;',
      errors: [{ message: "Variable 'myVariable' should be in PascalCase." }],
    },
    {
      code: 'let another_variable = 20;',
      output: 'let AnotherVariable = 20;',
      errors: [
        { message: "Variable 'another_variable' should be in PascalCase." },
      ],
    },
    {
      code: 'var somevar = "test";',
      output: 'var Somevar = "test";',
      errors: [{ message: "Variable 'somevar' should be in PascalCase." }],
    },
  ],
});



================================================
File: test/general/vars-snakecase.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester();

ruleTester.run('vars-snakecase', rules['vars-snakecase'], {
  valid: [
    // Valid test cases where variable names follow the snake_case convention
    {
      code: 'let my_variable = 1;',
    },
    {
      code: 'const another_variable = "test";',
    },
    {
      code: 'var some_var = true;',
    },
    {
      code: 'const snake_case_variable = 10;',
    },
  ],
  invalid: [
    // Invalid test cases where variable names don't follow the snake_case convention
    {
      code: 'let myVariable = 1;',
      errors: [{ message: "Variable 'myVariable' should be in snake_case." }],
      output: 'let my_variable = 1;',
    },
    {
      code: 'const anotherVariable = "test";',
      errors: [
        { message: "Variable 'anotherVariable' should be in snake_case." },
      ],
      output: 'const another_variable = "test";',
    },
    {
      code: 'var SomeVar = true;',
      errors: [{ message: "Variable 'SomeVar' should be in snake_case." }],
      output: 'var some_var = true;',
    },
    {
      code: 'let leadingUnderscoreVariable = 5;',
      errors: [
        {
          message:
            "Variable 'leadingUnderscoreVariable' should be in snake_case.",
        },
      ],
      output: 'let leading_underscore_variable = 5;',
    },
    {
      code: 'const camelCaseVar = 10;',
      errors: [{ message: "Variable 'camelCaseVar' should be in snake_case." }],
      output: 'const camel_case_var = 10;',
    },
  ],
});



================================================
File: test/react/react-component-name-match-filename.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester({
  languageOptions: {
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run(
  'react-component-name-match-filename',
  rules['react-component-name-match-filename'],
  {
    valid: [
      {
        code: `
        import React from 'react';

        class MyComponent extends React.Component {
          render() {
            return <div></div>;
          }
        }

        export default MyComponent;
      `,
        filename: 'MyComponent.jsx',
      },
      {
        code: `
        import React from 'react';

        function MyComponent() {
          return <div></div>;
        }

        export default MyComponent;
      `,
        filename: 'MyComponent.tsx',
      },
      // Files without React or JSX (non-React)
      {
        code: 'const myVariable = 42;',
        filename: 'myVariable.js', // No JSX, should not trigger PascalCase check
      },
      {
        code: 'function helperFunction() { return true; }',
        filename: 'helperFunction.ts', // No JSX, should not trigger PascalCase check
      },
    ],
    invalid: [
      {
        code: `
        import React from 'react';

        function MyComponent() {
          return <div></div>;
        }

        export default MyComponent;
      `,
        filename: 'AnotherComponent.tsx',
        errors: [
          {
            message:
              "Component name 'MyComponent' should match the filename 'AnotherComponent.tsx'.",
          },
        ],
      },
      {
        code: `
        import React from 'react';

        class MyComponent extends React.Component {
          render() {
            return <div></div>;
          }
        }

        export default MyComponent;
      `,
        filename: 'WrongComponent.jsx',
        errors: [
          {
            message:
              "Component name 'MyComponent' should match the filename 'WrongComponent.jsx'.",
          },
        ],
      },
    ],
  }
);



================================================
File: test/react/react-filename-pascalcase.test.js
================================================
const { RuleTester } = require('eslint');
const rules = require('../../index').rules;

const ruleTester = new RuleTester({
  languageOptions: {
    parserOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      ecmaFeatures: {
        jsx: true,
      },
    },
  },
});

ruleTester.run(
  'react-filename-pascalcase',
  rules['react-filename-pascalcase'],
  {
    valid: [
      // React Components with valid PascalCase filenames
      {
        code: 'const Component = () => <div>Hello</div>;',
        filename: 'Component.jsx',
      },
      {
        code: 'function MyComponent() { return <div>Hello</div>; }',
        filename: 'MyComponent.tsx',
      },
      {
        code: 'class MyComponent extends React.Component { render() { return <div></div>; }}',
        filename: 'MyComponent.js',
      },
      {
        code: 'const MyComponent = () => <div>Hello</div>;',
        filename: 'MyComponent.ts',
      },
      // Files without React or JSX (non-React)
      {
        code: 'const myVariable = 42;',
        filename: 'myVariable.js', // No JSX, should not trigger PascalCase check
      },
      {
        code: 'function helperFunction() { return true; }',
        filename: 'helperFunction.ts', // No JSX, should not trigger PascalCase check
      },
    ],
    invalid: [
      // React components with invalid filenames
      {
        code: 'const component = () => <div>Hello</div>;',
        filename: 'component.jsx',
        errors: [
          { message: "Filename 'component.jsx' should be in PascalCase." },
        ],
      },
      {
        code: `import React from 'react'; function MyComponent() { return <div></div>; }`,
        filename: 'anotherComponent.tsx',
        errors: [
          {
            message: "Filename 'anotherComponent.tsx' should be in PascalCase.",
          },
        ],
      },
      {
        code: `const myComponent = () => <div></div>;`,
        filename: 'myComponent.js',
        errors: [
          { message: "Filename 'myComponent.js' should be in PascalCase." },
        ],
      },
      {
        code: `function myComponent() { return <div></div>; }`,
        filename: 'myComponent.ts',
        errors: [
          { message: "Filename 'myComponent.ts' should be in PascalCase." },
        ],
      },
      // Mixed case: Filename is lowercase but contains JSX (React)
      {
        code: 'const MyComponent = () => <div>Hello</div>;',
        filename: 'component.js',
        errors: [
          { message: "Filename 'component.js' should be in PascalCase." },
        ],
      },
    ],
  }
);



================================================
File: .github/PULL_REQUEST_TEMPLATE.md
================================================
---
name: Pull Request
about: Submit a pull request to propose changes to the project
title: '[PR] '
labels: ''
assignees: ''
---

**Description**

A clear and concise description of the changes you have made. Explain why these changes are necessary.

**Related Issue**

Link to any related issues or tasks. For example: `Closes #123`, `Related to #456`.

**Type of Change**

- [ ] Bug fix
- [ ] New feature
- [ ] Enhancement
- [ ] Documentation update
- [ ] Other (please specify):

**How to Test**

Steps to test your changes. If applicable, provide code examples or command-line instructions.

1. Step 1
2. Step 2
3. Step 3

**Checklist**

- [ ] My code follows the project's coding style.
- [ ] I have updated the documentation as necessary.
- [ ] I have added tests to cover my changes.
- [ ] All existing and new tests pass.

**Additional Notes**

Add any other information or context that reviewers should know about your pull request.

---

Thank you for your contribution!



================================================
File: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
 name: Bug report  
 about: Create a report to help us improve
 title: '[BUG]'
 labels: bug
---

<!-- ✨ Thanks for reporting a bug! ➡️ Please follow this template to help us resolve the issue faster. -->

### 1️⃣ Describe the issue

Explain what’s not working correctly with the rule.

### 2️⃣ Affected Rule

Specify the rule that's causing the issue.

### 3️⃣ Code Example

Provide a code snippet where the issue can be reproduced.

```js
// Example code triggering the issue
const code = 'that should be ok';
```

### 4️⃣ Expected Behavior

Describe what you expected to happen.

### 5️⃣ Environment

- **ESLint Plugin Hub version:** [e.g. 1.0.0]
- **ESLint version:** [e.g. 7.32.0]
- **Node.js version:** [e.g. 14.17.0]
- **Operating System:** [e.g. macOS 11.4]



================================================
File: .github/ISSUE_TEMPLATE/rule_change.md
================================================
---
 name: Rule Change  
 about: Propose a change to an existing rule  
 title: '[RULE CHANGE]'  
 labels: rule change  
---

<!-- ✨ Thanks for suggesting a rule change! ➡️ Please follow this template to ensure we understand your proposal clearly. -->

### 1️⃣ Which rule are you proposing to change?

Specify the name of the rule you’d like to modify.

### 2️⃣ Describe the change you'd like

Provide a clear and concise description of the change you are proposing. Include code examples if applicable.

```js
// Example of the current rule behavior
const currentCode = '...';

// Example of the expected behavior after the change
const expectedCode = '...';
```

### 3️⃣ Is your change request related to a problem? Please describe

Explain if this change addresses a problem or frustration you’ve encountered.

### 4️⃣ Describe alternatives you've considered

Outline any alternative solutions or features you have considered.

### 5️⃣ Additional context

Include any other relevant context, screenshots, or details related to your request.



================================================
File: .github/ISSUE_TEMPLATE/rule_proposal.md
================================================
---
 name: Rule Proposal  
 about: Suggest a new rule for this project  
 title: '[NEW RULE]'  
 labels: new rule
---

<!-- ✨ Thanks for proposing a new rule! ➡️ Please follow this template to provide all the necessary details for your suggestion. -->

### 1️⃣ Is your rule proposal related to a problem? Please describe

Provide a clear and concise description of the problem you’re addressing. For example: "I’m always frustrated when..."

### 2️⃣ Describe the solution you'd like

Explain what you want the rule to enforce or disallow. Provide code examples to clarify the desired behavior.

```js
// Code that should be allowed or disallowed by the rule
const example = 'valid or invalid code based on the rule';
```

### 3️⃣ Describe alternatives you've considered

Outline any alternative solutions or workarounds you’ve explored.

### 4️⃣ Example configuration

Show how you expect the rule to be configured in an ESLint config file.

```json
{
  "rules": {
    "hub/new-rule": ["error", { "option": "value" }]
  }
}
```

### 5️⃣ Additional context

Add any other relevant details, context, or screenshots related to the rule proposal.



================================================
File: .github/workflows/release.yml
================================================
name: Deployment Workflow

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  build:
    name: "@mindfiredigital/eslint-plugin-hub"
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: read
    steps:
      - name: "Checkout repository"
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: "Install dependencies"
        run: npm ci

      - name: "Lint code"
        run: npm run lint

      - name: "Run tests"
        run: npm test

      - name: "Restore changes in json"
        run: |
          git restore package-lock.json

      - name: "Set Git user name and email"
        run: |
          git config --local user.email "github-actions@github.com"
          git config --local user.name "GitHub Actions"

  create-github-release:
    name: Create GitHub release document and publish to npm
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'

      - name: Install dependencies
        run: npm ci

      - name: Semantic Release and npm release
        run: |
          npx semantic-release
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify .npmignore files
        run: |
          echo "Files included in npm package:"
          npm pack --dry-run



================================================
File: .husky/commit-msg
================================================
npx --no -- commitlint --edit "$1"


================================================
File: .husky/pre-commit
================================================
npx lint-staged


================================================
File: .husky/_/applypatch-msg
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/commit-msg
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/h
================================================
#!/usr/bin/env sh
[ "$HUSKY" = "2" ] && set -x
n=$(basename "$0")
s=$(dirname "$(dirname "$0")")/$n

[ ! -f "$s" ] && exit 0

if [ -f "$HOME/.huskyrc" ]; then
	echo "husky - '~/.huskyrc' is DEPRECATED, please move your code to ~/.config/husky/init.sh"
fi
i="${XDG_CONFIG_HOME:-$HOME/.config}/husky/init.sh"
[ -f "$i" ] && . "$i"

[ "${HUSKY-}" = "0" ] && exit 0

export PATH="node_modules/.bin:$PATH"
sh -e "$s" "$@"
c=$?

[ $c != 0 ] && echo "husky - $n script failed (code $c)"
[ $c = 127 ] && echo "husky - command not found in PATH=$PATH"
exit $c



================================================
File: .husky/_/husky.sh
================================================
echo "husky - DEPRECATED

Please remove the following two lines from $0:

#!/usr/bin/env sh
. \"\$(dirname -- \"\$0\")/_/husky.sh\"

They WILL FAIL in v10.0.0
"


================================================
File: .husky/_/post-applypatch
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/post-checkout
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/post-commit
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/post-merge
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/post-rewrite
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-applypatch
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-auto-gc
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-commit
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-merge-commit
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-push
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/pre-rebase
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/prepare-commit-msg
================================================
#!/usr/bin/env sh
. "$(dirname "$0")/h"


================================================
File: .husky/_/.gitignore
================================================
*

